<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lazybones Kill PLAN</title>
  <subtitle>In me the tiger sniffs the rose</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://vrast.cn/"/>
  <updated>2018-04-08T06:17:28.733Z</updated>
  <id>http://vrast.cn/</id>
  
  <author>
    <name>keyle xiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>protobuf中使用继承</title>
    <link href="http://vrast.cn/posts/67edd270/"/>
    <id>http://vrast.cn/posts/67edd270/</id>
    <published>2018-04-08T06:06:57.000Z</published>
    <updated>2018-04-08T06:17:28.733Z</updated>
    
    <content type="html"><![CDATA[<p>前两天有一个问题一直困扰我。使用protobuf .net版本的时候序列化类，基类的字段会丢失。随后我问了下朋友无一例外他们都使用的是组合而非继承。我也在反思是否这个做法本身就有问题。我昨天Google的时候发现有人遇到相同的问题，遂在本篇中记录。</p>
<a id="more"></a>
<p><a href="https://stackoverflow.com/questions/6109868/protobuf-net-base-class-properties-is-not-included-when-serializing-derived-clas" target="_blank" rel="external">ProtoBuf.net Base class properties is not included when serializing derived class</a> 这个就是我遇到的问题，一摸一样。<br>解决方案如下：如果是子类想要在序列化的时候带上基类的信息请使用【ProtoInclude】，填写上想要包含的类型即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天有一个问题一直困扰我。使用protobuf .net版本的时候序列化类，基类的字段会丢失。随后我问了下朋友无一例外他们都使用的是组合而非继承。我也在反思是否这个做法本身就有问题。我昨天Google的时候发现有人遇到相同的问题，遂在本篇中记录。&lt;/p&gt;
    
    </summary>
    
      <category term="UNITY3D" scheme="http://vrast.cn/categories/UNITY3D/"/>
    
    
      <category term="protobuf" scheme="http://vrast.cn/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title>编辑器扩展-分割条</title>
    <link href="http://vrast.cn/posts/8d62e7c3/"/>
    <id>http://vrast.cn/posts/8d62e7c3/</id>
    <published>2018-03-27T01:40:57.000Z</published>
    <updated>2018-03-27T01:52:39.284Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>可拖动分割条在 Unity3D 的编辑器结构中一般都属于最外层结构，因为它是基于 GUI 组件，计算位置的时候必须要很精确，所以跟Layout 流式布局混编会比较乱。这里也推荐作为最外层结构使用。</p>
</blockquote>
<p><img src="/uploads/2018427047.png" alt="可拖动的分割条"><br><a id="more"></a></p>
<h1 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h1><p>下面是我写的一个演示例子 你可以在Unity中直接运行。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//   		Copyright 2017 KeyleXiao.</span></div><div class="line"><span class="comment">//     		Contact : Keyle_xiao@hotmail.com </span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//     		Licensed under the Apache License, Version 2.0 (the "License");</span></div><div class="line"><span class="comment">//     		you may not use this file except in compliance with the License.</span></div><div class="line"><span class="comment">//     		You may obtain a copy of the License at</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//     		http://www.apache.org/licenses/LICENSE-2.0</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//     		Unless required by applicable law or agreed to in writing, software</span></div><div class="line"><span class="comment">//     		distributed under the License is distributed on an "AS IS" BASIS,</span></div><div class="line"><span class="comment">//     		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></div><div class="line"><span class="comment">//     		See the License for the specific language governing permissions and</span></div><div class="line"><span class="comment">//     		limitations under the License.</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="keyword">using</span>  UnityEditor;</div><div class="line"><span class="keyword">using</span> UnityEngine;</div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">SmartDataViewer.Editor</span></div><div class="line">&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExportWizard</span>:<span class="title">EditorWindow</span></div><div class="line">    &#123;</div><div class="line">        [MenuItem(<span class="string">"SmartDataViewer/ExportWizard"</span>)]</div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OpenView</span>(<span class="params"></span>)</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">var</span> w = CreateInstance&lt;ExportWizard &gt;();</div><div class="line">            </div><div class="line">            w.minSize = <span class="keyword">new</span> Vector2(<span class="number">350</span>,<span class="number">250</span>);</div><div class="line">            w.maxSize = w.minSize;</div><div class="line">            Vector2 pos =<span class="keyword">new</span> Vector2( Screen.width/<span class="number">2</span>-w.minSize.x,Screen.height/<span class="number">2</span>-w.minSize.y);</div><div class="line">            w.position = <span class="keyword">new</span> Rect(pos,w.minSize);</div><div class="line">            </div><div class="line">            w.ShowUtility();</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">object</span> rawData &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InitRawData</span>(<span class="params"><span class="keyword">object</span> data</span>)</span></div><div class="line">        &#123;</div><div class="line">            rawData = data;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="keyword">private</span> Vector2 scrollPos = Vector2.zero;</div><div class="line">        <span class="keyword">float</span> currentScrollViewWidth;</div><div class="line">        <span class="keyword">bool</span> resize = <span class="literal">false</span>;</div><div class="line">        Rect cursorChangeRect;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">this</span>.position = <span class="keyword">new</span> Rect(<span class="number">200</span>,<span class="number">200</span>,<span class="number">400</span>,<span class="number">300</span>);</div><div class="line">            currentScrollViewWidth = <span class="keyword">this</span>.position.width/<span class="number">2</span>;</div><div class="line">            cursorChangeRect = <span class="keyword">new</span> Rect(currentScrollViewWidth,<span class="number">0</span>,<span class="number">4</span>f,<span class="keyword">this</span>.position.height);</div><div class="line">        &#125;</div><div class="line">     </div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            GUILayout.BeginHorizontal();</div><div class="line">            </div><div class="line">            scrollPos = GUILayout.BeginScrollView(scrollPos,GUILayout.Width(currentScrollViewWidth));</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</div><div class="line">                GUILayout.Label(<span class="string">"test content"</span>);</div><div class="line">            GUILayout.EndScrollView();</div><div class="line">                 </div><div class="line">            ResizeScrollView();</div><div class="line">            </div><div class="line">            GUILayout.Label(<span class="string">"right part"</span>);</div><div class="line">            GUILayout.EndHorizontal();</div><div class="line">            Repaint();</div><div class="line">        &#125;</div><div class="line">     </div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ResizeScrollView</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            GUI.DrawTexture(cursorChangeRect,EditorGUIUtility.whiteTexture);</div><div class="line">            EditorGUIUtility.AddCursorRect(cursorChangeRect,MouseCursor.ResizeHorizontal);</div><div class="line">         </div><div class="line">            <span class="keyword">if</span>( Event.current.type == EventType.MouseDown &amp;&amp; cursorChangeRect.Contains(Event.current.mousePosition))&#123;</div><div class="line">                resize = <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(resize)&#123;</div><div class="line">                currentScrollViewWidth = Event.current.mousePosition.x;</div><div class="line">                cursorChangeRect.Set(currentScrollViewWidth,cursorChangeRect.y,cursorChangeRect.width,cursorChangeRect.height);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(Event.current.type == EventType.MouseUp)</div><div class="line">                resize = <span class="literal">false</span>;        </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>这里的GUI仅仅是做了一个表现，最核心的其实是 <code>cursorChangeRect</code> 因为你即使不要这个 GUI 也能在这个 Rect 的位置进行拖动。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GUI.DrawTexture(cursorChangeRect,EditorGUIUtility.whiteTexture);</div></pre></td></tr></table></figure></p>
<p>在鼠标移动的同时将鼠标当前 x 轴的位置赋前面的一个layout，就会推动后面一个layout. (流式布局)</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;可拖动分割条在 Unity3D 的编辑器结构中一般都属于最外层结构，因为它是基于 GUI 组件，计算位置的时候必须要很精确，所以跟Layout 流式布局混编会比较乱。这里也推荐作为最外层结构使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/uploads/2018427047.png&quot; alt=&quot;可拖动的分割条&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="UNITY3D" scheme="http://vrast.cn/categories/UNITY3D/"/>
    
    
      <category term="UNITY3D编辑器" scheme="http://vrast.cn/tags/UNITY3D%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>UNITY性能优化参考篇</title>
    <link href="http://vrast.cn/posts/69247612/"/>
    <id>http://vrast.cn/posts/69247612/</id>
    <published>2018-03-09T08:12:00.000Z</published>
    <updated>2018-03-09T11:07:23.840Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>下面是我给项目组的一些参考。其中也包含各种各样的标准，与优化建议。项目优化并不是一件事，它是点点滴滴串联起来的(勿以恶小而为之)，我见过很多项目只是图一时之方便就导致后期很难做 比如 前期未规划好图集，模型贴图材质目录混用，UI制作未按照 复用/特殊 的标准制作，动画导出帧率不统一高高低低 等等。如果一开始没有定制良好的规范，后面想要补救只能靠程序写一些工具批量处理，当然这工具也不一定好写。</p>
</blockquote>
<a id="more"></a>
<p>因为效率优化是一个很泛化的词。所以在这里我只讨论大类进而衍生出 “标准做法”。标准只说通用的，做了不会错的那种。如果你没有做 推荐你试一试。像如同项目贴图设置，灯光设置，烘焙，fog，等 设置问题这里不谈。因为设置的选项是最容易做优化的即使到了后期也是可以快速做的。</p>
<h2 id="美术资源"><a href="#美术资源" class="headerlink" title="美术资源"></a>美术资源</h2><h3 id="资源分级"><a href="#资源分级" class="headerlink" title="资源分级"></a>资源分级</h3><p>如 贴图png/jpg的选择 动画30帧还是60帧的选择 粒子质量高或低还是标准 等。根据不同场合使用不同级别资源。一般来说高质量资源只会出现在最显眼的地方 如 登陆，人物选择，入场。真正战斗调用的美术资源往往只需要普通品质即可。具体项目可以跟着需求来控制，划重点 这里要做差异化 才能省出资源(内存)。</p>
<h4 id="贴图的质量选择"><a href="#贴图的质量选择" class="headerlink" title="贴图的质量选择"></a>贴图的质量选择</h4><p><img src="/uploads/texturequality.png" alt="可参考 https://www.jianshu.com/p/f7c3741f22af"><br>贴图的质量选择主要影响运行时效率，并不影响出包的大小。UNITY3D打包会自己优化图片大小，如果你使用了android studio release 打包，大小会进一步压缩。<br>这里可以想象一下内存与效率的转化。内存占比越高越清晰。这个可以直接通过贴图的前缀或者后缀统一设置。或者写一个资源管理工具 统一设置。</p>
<h2 id="冷热分离-延迟加载"><a href="#冷热分离-延迟加载" class="headerlink" title="冷热分离 延迟加载"></a>冷热分离 延迟加载</h2><ol>
<li>使用延迟加载，如果需要集中加载某些资源可以考虑冷热分离。常驻内存中的资源 与 非常驻内存中的资源采取不同策略：<br>战斗配置 等到战斗场景再加载，关卡/任务/成就/ 等等其他 可以等到打开具体面板或进入场景的时候做一次缓存。</li>
<li>移除空函数 如 继承自MB的 Update 之类的函数。</li>
<li>分帧做iO 或 网络请求的操作。再具体一点就是用携程 该return的地方就return 等候下一帧处理。</li>
<li>高消耗的函数避免甚至不用 基本上UNITY API中以Findxxx开头 返回一个 List 的函数都是高消耗函数。</li>
</ol>
<h2 id="内存控制"><a href="#内存控制" class="headerlink" title="内存控制"></a>内存控制</h2><ol>
<li>使用缓存池 如 通用面板/通用弹出美术字(战斗中伤害数字)/ 等考虑缓存。</li>
<li>监测当前工程在移动端的内存占用，给所有的缓存池增加释放接口 做一些排序释放操作(优先级释放)。<br>可以参考 UNITY5.6 的新API <a href="https://docs.unity3d.com/ScriptReference/Application-lowMemory.html" target="_blank" rel="external">Application.lowMemory</a></li>
<li>使用压缩过的音频 或者 使用 Fmod 之类的插件进行托管。缺氧使用的就是 fmod .</li>
<li>文本配置转2进制存储 减少运行时内存占用。</li>
</ol>
<h2 id="效率重点"><a href="#效率重点" class="headerlink" title="效率重点"></a>效率重点</h2><ol>
<li>使用 line fog 调整相机视野</li>
<li>关闭场景阴影 能用烘焙用烘焙。 </li>
<li>使用 Fast Shadow Projector 做阴影。</li>
<li>不要使用standard shader。因为大量的实时GI运算。</li>
</ol>
<h2 id="打包事项"><a href="#打包事项" class="headerlink" title="打包事项"></a>打包事项</h2><ol>
<li>iOS 如果可以就使用 bit code</li>
<li>APK 使用 Android Studio release 打包</li>
<li>使用  <code>.NET 2.0 Subset </code> 使用脚本代替如 xml 之类的system库的使用。</li>
<li>打包完之后查看 log 确定资源瓶颈。推荐使用 <code>Build Report Tool</code><br>某宝五毛钱能买到最新版。每次打包都需要看一眼，真等到需要做优化的时候已经晚了，优化的需求往往是积累到一定程度才爆发需要优化。</li>
<li>打包过atlas的图就不要再放到Resources下，方便的话就打包成AB</li>
</ol>
<h2 id="一些具体的优化资料"><a href="#一些具体的优化资料" class="headerlink" title="一些具体的优化资料"></a>一些具体的优化资料</h2><p><a href="https://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html" target="_blank" rel="external">官网 图形性能优化</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;下面是我给项目组的一些参考。其中也包含各种各样的标准，与优化建议。项目优化并不是一件事，它是点点滴滴串联起来的(勿以恶小而为之)，我见过很多项目只是图一时之方便就导致后期很难做 比如 前期未规划好图集，模型贴图材质目录混用，UI制作未按照 复用/特殊 的标准制作，动画导出帧率不统一高高低低 等等。如果一开始没有定制良好的规范，后面想要补救只能靠程序写一些工具批量处理，当然这工具也不一定好写。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="UNITY" scheme="http://vrast.cn/categories/UNITY/"/>
    
    
      <category term="性能优化" scheme="http://vrast.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Unity new API</title>
    <link href="http://vrast.cn/posts/76c9e56/"/>
    <id>http://vrast.cn/posts/76c9e56/</id>
    <published>2018-02-26T11:17:08.000Z</published>
    <updated>2018-02-27T07:19:38.124Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这里记录一些Unity3D的API 以备不时之需。</p>
</blockquote>
<a id="more"></a>
<h1 id="Application-lowMemory-低内存检测-5-6"><a href="#Application-lowMemory-低内存检测-5-6" class="headerlink" title="Application.lowMemory 低内存检测 5.6+"></a>Application.lowMemory 低内存检测 5.6+</h1><p>当Andorid或者iOS内存过低会调用此函数。用来处理内存释放 <a href="https://docs.unity3d.com/ScriptReference/Application-lowMemory.html" target="_blank" rel="external">官网文档</a><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> UnityEngine;</div><div class="line"><span class="keyword">using</span> System.Collections;</div><div class="line"><span class="keyword">using</span> System.Collections.Generic;</div><div class="line"></div><div class="line"><span class="keyword">class</span> <span class="title">LowMemoryTrigger</span> : <span class="title">MonoBehaviour</span></div><div class="line">&#123;</div><div class="line">    List&lt;Texture2D&gt; _textures;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></div><div class="line">    &#123;</div><div class="line">        _textures = <span class="keyword">new</span> List&lt;Texture2D&gt;();</div><div class="line">        Application.lowMemory += OnLowMemory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// allocate textures until we run out of memory</span></div><div class="line">        _textures.Add(<span class="keyword">new</span> Texture2D(<span class="number">256</span>, <span class="number">256</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnLowMemory</span>(<span class="params"></span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// release all cached textures</span></div><div class="line">        _textures = <span class="keyword">new</span> List&lt;Texture2D&gt;();</div><div class="line">        Resources.UnloadUnusedAssets();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录一些Unity3D的API 以备不时之需。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="UNITYAPI" scheme="http://vrast.cn/categories/UNITYAPI/"/>
    
    
      <category term="UNITY3D" scheme="http://vrast.cn/tags/UNITY3D/"/>
    
  </entry>
  
  <entry>
    <title>SNFramework</title>
    <link href="http://vrast.cn/posts/f326c5ce/"/>
    <id>http://vrast.cn/posts/f326c5ce/</id>
    <published>2018-01-16T01:31:33.000Z</published>
    <updated>2018-01-16T05:57:48.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h1><p>2015年 我在淘米写了一套 <a href="http://www.cnblogs.com/Keyle/p/4843934.html" target="_blank" rel="external">消息传递机制</a> 当然这一套在我的上家公司也得到验证。<br>2016年 我在世纪创意基于2015年一版的消息传递进行了封装但是当时赶项目也没有引入。我称之为 <a href="https://gitee.com/keyle/SmartNotificationFramework" target="_blank" rel="external">SmartNotificationFramework</a> 我希望它能达到足够的灵活，在我看来它工作的还不错，但是太简陋。<br>2018年 也就是今年我终于得空并且集中时间大量重构与完成了大部分的单元测试。SNFramework 是我正在使用的消息传递机制。它已经有了初步的理想功能，如消息上下分隔离，消息被阅读成功自动释放(即指执行一次)，广播消息等。</p>
<h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a href="https://github.com/KeyleXiao/SNFramework" target="_blank" rel="external">https://github.com/KeyleXiao/SNFramework</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;起源&quot;&gt;&lt;a href=&quot;#起源&quot; class=&quot;headerlink&quot; title=&quot;起源&quot;&gt;&lt;/a&gt;起源&lt;/h1&gt;&lt;p&gt;2015年 我在淘米写了一套 &lt;a href=&quot;http://www.cnblogs.com/Keyle/p/4843934.html&quot; t
    
    </summary>
    
      <category term="OpenSource" scheme="http://vrast.cn/categories/OpenSource/"/>
    
    
      <category term="SNFramework" scheme="http://vrast.cn/tags/SNFramework/"/>
    
  </entry>
  
  <entry>
    <title>分析缺氧(Oxygen not included)中所用到的技术</title>
    <link href="http://vrast.cn/posts/6f00466c/"/>
    <id>http://vrast.cn/posts/6f00466c/</id>
    <published>2018-01-03T09:03:16.000Z</published>
    <updated>2018-01-03T10:53:07.537Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>元旦期间玩了缺氧，感觉十分的好玩。属于深度沙盒经营类游戏。既然好玩那就要知其所以然，今天抽空看了看源码，基本上列出所有能找到的工具或技术。算是一个记录，也开阔一下视野。如果你还有什么补充欢迎给我留言。</p>
</blockquote>
<a id="more"></a>
<h1 id="外部插件列表"><a href="#外部插件列表" class="headerlink" title="外部插件列表"></a>外部插件列表</h1><h2 id="YamlDotNet-amp-Newtonsoft-Json"><a href="#YamlDotNet-amp-Newtonsoft-Json" class="headerlink" title="YamlDotNet &amp; Newtonsoft.Json"></a>YamlDotNet &amp; Newtonsoft.Json</h2><p>序列化工具<br><a href="https://github.com/aaubry/YamlDotNet" target="_blank" rel="external">Github地址</a><br><a href="https://dotnetfiddle.net/QlqGDV" target="_blank" rel="external">代码演示地址1</a><br><a href="https://dotnetfiddle.net/HD2JXM" target="_blank" rel="external">代码演示地址2</a></p>
<p>Newtonsoft.Json 就不说了 这个大家都知道，毕竟不是小众</p>
<h2 id="FileHelpers-Library"><a href="#FileHelpers-Library" class="headerlink" title="FileHelpers Library"></a>FileHelpers Library</h2><p>FileHelpers Library是一款C#编写的开源 .NET 类库。它使用简单，很容易就可以从固定长度文件或界定记录(CSV)读/写数据。它也支持从不同的数据存储格式(Excel, Access, SqlServer)导入/导出数据。 <a href="http://www.filehelpers.net" target="_blank" rel="external">FileHelpers官网</a></p>
<h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><p>ArabicSuppor.dll  阿拉伯语支持<br>I18N.dll / I18N.West.dll Unity自带的国际化工具</p>
<h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>Ionic.Zip 老牌的解压与压缩类库 <a href="https://dotnetzip.codeplex.com" target="_blank" rel="external">项目地址 Codeplex</a><br>SharpZipLib C#解压压缩类库 <a href="https://github.com/icsharpcode/SharpZipLib" target="_blank" rel="external">项目地址</a></p>
<h2 id="噪声"><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h2><p>libnoise.dll 用于随机算法(噪声)  <a href="http://libnoise.sourceforge.net" target="_blank" rel="external">项目地址</a></p>
<h2 id="Png读写"><a href="#Png读写" class="headerlink" title="Png读写"></a>Png读写</h2><p>Pngcs 用来对png图读写的工具 <a href="https://github.com/leonbloy/pngcs" target="_blank" rel="external">Pngcs项目地址</a><br>我猜主场景的图片应该在不停的读写，这样比生成10000*10000的贴图效率高的多。</p>
<h1 id="内部引用插件列表"><a href="#内部引用插件列表" class="headerlink" title="内部引用插件列表"></a>内部引用插件列表</h1><h2 id="Node-Editor-Framework"><a href="#Node-Editor-Framework" class="headerlink" title="Node_Editor_Framework"></a>Node_Editor_Framework</h2><p>节点编辑器 经过源码比对 klei 拿这个源码自己改了一版，不过确实使用了这个项目 <a href="https://github.com/Seneral/Node_Editor_Framework" target="_blank" rel="external">项目地址</a></p>
<h2 id="fmod-studio"><a href="#fmod-studio" class="headerlink" title="fmod.studio"></a>fmod.studio</h2><p>Unity内置了Audio功能，并且底层也是用FMOD来实现的，为什么还要不辞劳苦学习使用FMOD插件来进行音效的管理？<br>-<a href="https://www.jianshu.com/p/586a5d465827" target="_blank" rel="external">FMOD学习 - 简书</a></p>
<h2 id="TMPro"><a href="#TMPro" class="headerlink" title="TMPro"></a>TMPro</h2><p>Mesh字体插件 <a href="https://www.assetstore.unity3d.com/en/#!/content/84126" target="_blank" rel="external">AssetStore地址</a></p>
<h2 id="procgen"><a href="#procgen" class="headerlink" title="procgen"></a>procgen</h2><p>程序上实现噪声算法 <a href="https://github.com/trentpolack/procgen" target="_blank" rel="external">项目地址</a></p>
<h2 id="图形学插件"><a href="#图形学插件" class="headerlink" title="图形学插件"></a>图形学插件</h2><h3 id="Delaunay"><a href="#Delaunay" class="headerlink" title="Delaunay"></a>Delaunay</h3><p>三角形破裂算法 在github上搜这个关键字就好了</p>
<h3 id="ClipperLib"><a href="#ClipperLib" class="headerlink" title="ClipperLib"></a>ClipperLib</h3><p>多边形偏移裁切算法 <a href="http://www.angusj.com/delphi/clipper.php" target="_blank" rel="external">项目地址</a></p>
<h3 id="MIConvexHull"><a href="#MIConvexHull" class="headerlink" title="MIConvexHull"></a>MIConvexHull</h3><p>可以生成2、3维的最小凸包。可以进行狄洛尼三角剖分，生成Voronoi多边形。<br><a href="https://github.com/DesignEngrLab/MIConvexHull" target="_blank" rel="external">项目地址</a></p>
<h3 id="Voronoi-Tree"><a href="#Voronoi-Tree" class="headerlink" title="Voronoi Tree"></a>Voronoi Tree</h3><p>泰森多边形<br><a href="https://en.m.wikipedia.org/wiki/Voronoi_diagram" target="_blank" rel="external">算法简介</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;元旦期间玩了缺氧，感觉十分的好玩。属于深度沙盒经营类游戏。既然好玩那就要知其所以然，今天抽空看了看源码，基本上列出所有能找到的工具或技术。算是一个记录，也开阔一下视野。如果你还有什么补充欢迎给我留言。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://vrast.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="缺氧源码分析" scheme="http://vrast.cn/tags/%E7%BC%BA%E6%B0%A7%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>动态获取AgentTypeID</title>
    <link href="http://vrast.cn/posts/9ad4f6c3/"/>
    <id>http://vrast.cn/posts/9ad4f6c3/</id>
    <published>2017-12-22T14:25:55.000Z</published>
    <updated>2017-12-22T14:35:38.761Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>前阵子我在Github上给Unity团队提了一个issue关于使用代码获取<code>agentTypeID</code>，说来惭愧是我自己的没找到对应的代码。在我使用另外渠道获取此ID的时候 Unity团队已经默默给我回复了这个issues.先说说我的解决方式，由于代码设置 agentTypeID 的时候需要给一个Int类型变量，这个变量其实是对应了一个枚举，我在UnityEditor Inspector的Debug窗口中直接获取了对应AgentTypeID. 笑. 本文记录我获得答复的过程，换个角度想想其实也能发现另外的解决方案即使不知道也没关系<br>。</p>
</blockquote>
<p><img src="/uploads/navmeshagentid.png" alt="解决方案"></p>
<a id="more"></a>
<h1 id="图中的代码如下"><a href="#图中的代码如下" class="headerlink" title="图中的代码如下"></a>图中的代码如下</h1><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count = NavMesh.GetSettingsCount();</div><div class="line"><span class="keyword">var</span> agentTypeNames = <span class="keyword">new</span> <span class="keyword">string</span>[count + <span class="number">2</span>];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">var</span> id = NavMesh.GetSettingsByIndex(i).agentTypeID;</div><div class="line">    <span class="keyword">var</span> name = NavMesh.GetSettingsNameFromID(id);</div><div class="line">    agentTypeNames[i] = name;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前阵子我在Github上给Unity团队提了一个issue关于使用代码获取&lt;code&gt;agentTypeID&lt;/code&gt;，说来惭愧是我自己的没找到对应的代码。在我使用另外渠道获取此ID的时候 Unity团队已经默默给我回复了这个issues.先说说我的解决方式，由于代码设置 agentTypeID 的时候需要给一个Int类型变量，这个变量其实是对应了一个枚举，我在UnityEditor Inspector的Debug窗口中直接获取了对应AgentTypeID. 笑. 本文记录我获得答复的过程，换个角度想想其实也能发现另外的解决方案即使不知道也没关系&lt;br&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/uploads/navmeshagentid.png&quot; alt=&quot;解决方案&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="UNITY3D" scheme="http://vrast.cn/categories/UNITY3D/"/>
    
    
      <category term="NavmeshAgent" scheme="http://vrast.cn/tags/NavmeshAgent/"/>
    
  </entry>
  
  <entry>
    <title>三维向量曲线平滑算法</title>
    <link href="http://vrast.cn/posts/7a035f20/"/>
    <id>http://vrast.cn/posts/7a035f20/</id>
    <published>2017-12-22T02:37:36.000Z</published>
    <updated>2017-12-22T14:37:40.822Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在网上看到一个平滑算法，很好用，经过我测试 效率很高，Chaikin 函数调用2-3次会获得一个相对较好的曲线。<a href="http://graphics.cs.ucdavis.edu/education/CAGDNotes/Chaikins-Algorithm/Chaikins-Algorithm.html" target="_blank" rel="external">算法链接</a><br>原理是不断的裁切三角形让其分裂成2个三角，2个三角变成4个，以此类推，最终会越来越平滑从而接近一个圆。</p>
</blockquote>
<p><img src="/uploads/chaikin_algorithm.png" alt="裁切范例"></p>
<a id="more"></a>
<p>平滑算法如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> UnityEngine;</div><div class="line"><span class="keyword">using</span> System.Collections;</div><div class="line"></div><div class="line">[RequireComponent(<span class="keyword">typeof</span>(LineRenderer))]</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SmoothAlgorithm</span> : <span class="title">MonoBehaviour</span></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> minRadius = <span class="number">1.5</span>f;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> maxRadius = <span class="number">3.5</span>f;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">25</span>;</div><div class="line">    <span class="keyword">private</span> LineRenderer lr;</div><div class="line">    <span class="keyword">private</span> Vector3[] points;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></div><div class="line">    &#123;</div><div class="line">        lr = GetComponent&lt;LineRenderer&gt;();</div><div class="line">        GenerateRandomPath();</div><div class="line">        SetLR(points);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GenerateRandomPath</span>(<span class="params"></span>)</span></div><div class="line">    &#123;</div><div class="line">        points = <span class="keyword">new</span> Vector3[num];</div><div class="line"></div><div class="line">        <span class="keyword">float</span> angle = <span class="number">360.0</span>f / num;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</div><div class="line">        &#123;</div><div class="line">            points[i] = Quaternion.AngleAxis((angle * i), Vector3.forward) * Vector3.up * Random.Range(minRadius, maxRadius);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetLR</span>(<span class="params">Vector3[] pts</span>)</span></div><div class="line">    &#123;</div><div class="line">        lr.SetVertexCount(pts.Length);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pts.Length; i++)</div><div class="line">        &#123;</div><div class="line">            lr.SetPosition(i, pts[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</div><div class="line">        &#123;</div><div class="line">            points = Chaikin(points);</div><div class="line">            SetLR(points);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.G))</div><div class="line">        &#123;</div><div class="line">            GenerateRandomPath();</div><div class="line">            SetLR(points);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">Vector3[] <span class="title">Chaikin</span>(<span class="params">Vector3[] pts</span>)</span></div><div class="line">    &#123;</div><div class="line">        Vector3[] newPts = <span class="keyword">new</span> Vector3[(pts.Length - <span class="number">2</span>) * <span class="number">2</span> + <span class="number">2</span>];</div><div class="line">        newPts[<span class="number">0</span>] = pts[<span class="number">0</span>];</div><div class="line">        newPts[newPts.Length - <span class="number">1</span>] = pts[pts.Length - <span class="number">1</span>];</div><div class="line"></div><div class="line">        <span class="keyword">int</span> j = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pts.Length - <span class="number">2</span>; i++)</div><div class="line">        &#123;</div><div class="line">            newPts[j] = pts[i] + (pts[i + <span class="number">1</span>] - pts[i]) * <span class="number">0.75</span>f;</div><div class="line">            newPts[j + <span class="number">1</span>] = pts[i + <span class="number">1</span>] + (pts[i + <span class="number">2</span>] - pts[i + <span class="number">1</span>]) * <span class="number">0.25</span>f;</div><div class="line">            j += <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> newPts;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在网上看到一个平滑算法，很好用，经过我测试 效率很高，Chaikin 函数调用2-3次会获得一个相对较好的曲线。&lt;a href=&quot;http://graphics.cs.ucdavis.edu/education/CAGDNotes/Chaikins-Algorithm/Chaikins-Algorithm.html&quot;&gt;算法链接&lt;/a&gt;&lt;br&gt;原理是不断的裁切三角形让其分裂成2个三角，2个三角变成4个，以此类推，最终会越来越平滑从而接近一个圆。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/uploads/chaikin_algorithm.png&quot; alt=&quot;裁切范例&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Math" scheme="http://vrast.cn/categories/Math/"/>
    
    
      <category term="算法" scheme="http://vrast.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>使用物理检测范围与距离内的目标</title>
    <link href="http://vrast.cn/posts/e0406d64/"/>
    <id>http://vrast.cn/posts/e0406d64/</id>
    <published>2017-12-16T16:30:27.000Z</published>
    <updated>2017-12-17T11:43:39.078Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>分享一个技围检测脚本，用来判定范围内是否有目标，或者是线性范围内是否可见目标。</p>
</blockquote>
<p><img src="/uploads/ScreenShot2017-12-17.png" alt="简洁范围检测"><br><a id="more"></a></p>
<h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> System.Collections;</div><div class="line"><span class="keyword">using</span> System.Collections.Generic;</div><div class="line"><span class="keyword">using</span> UnityEngine;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CheckSkillRange</span> : <span class="title">MonoBehaviour</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">public</span> Vector3 offset = Vector3.one;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">float</span> fieldOfViewAngle = <span class="number">20</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">float</span> viewDistance = <span class="number">4</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">bool</span> usePhysics2D = <span class="literal">false</span>;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> LayerMask ObjLayer = LayerMask.GetMask(<span class="string">"Default"</span>);</div><div class="line">  <span class="keyword">public</span> LayerMask IgnoreLayer = <span class="number">1</span>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">if</span> (Input.GetMouseButtonUp(<span class="number">1</span>))</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">var</span> o = MovementUtility.WithinSight(transform, offset, fieldOfViewAngle, viewDistance, ObjLayer, Vector3.zero, IgnoreLayer);</div><div class="line">      <span class="keyword">if</span> (o)</div><div class="line">      &#123;</div><div class="line">        Debug.Log(<span class="keyword">string</span>.Format(<span class="string">"Attack obj &#123;0&#125;"</span>, o.name));</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Draw the line of sight representation within the scene window</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDrawGizmos</span>(<span class="params"></span>)</span></div><div class="line">  &#123;</div><div class="line">    DrawLineOfSight(<span class="keyword">this</span>.transform, offset, fieldOfViewAngle, viewDistance, usePhysics2D);</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DrawLineOfSight</span>(<span class="params">Transform transform, Vector3 positionOffset, <span class="keyword">float</span> fieldOfViewAngle, <span class="keyword">float</span> viewDistance, <span class="keyword">bool</span> usePhysics2D</span>)</span></div><div class="line">  &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR</span></div><div class="line">    <span class="keyword">var</span> oldColor = UnityEditor.Handles.color;</div><div class="line">    <span class="keyword">var</span> color = Color.yellow;</div><div class="line">    color.a = <span class="number">0.1</span>f;</div><div class="line">    UnityEditor.Handles.color = color;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> halfFOV = fieldOfViewAngle * <span class="number">0.5</span>f;</div><div class="line">    <span class="keyword">var</span> beginDirection = Quaternion.AngleAxis(-halfFOV, (usePhysics2D ? Vector3.forward : Vector3.up)) * (usePhysics2D ? transform.up : transform.forward);</div><div class="line">    UnityEditor.Handles.DrawSolidArc(transform.TransformPoint(positionOffset), (usePhysics2D ? transform.forward : transform.up), beginDirection, fieldOfViewAngle, viewDistance);</div><div class="line"></div><div class="line">    UnityEditor.Handles.color = oldColor;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="核心类，使用物理检测距离目标等-核心还是使用了碰撞检测"><a href="#核心类，使用物理检测距离目标等-核心还是使用了碰撞检测" class="headerlink" title="核心类，使用物理检测距离目标等,核心还是使用了碰撞检测"></a>核心类，使用物理检测距离目标等,核心还是使用了碰撞检测</h1><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MovementUtility</span></div><div class="line">&#123;</div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// Static Fields</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Dictionary&lt;GameObject, AudioSource[]&gt; transformAudioSourceMap;</div><div class="line"></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// Static Methods</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DrawLineOfSight</span>(<span class="params">Transform transform, Vector3 positionOffset, <span class="keyword">float</span> fieldOfViewAngle, <span class="keyword">float</span> angleOffset, <span class="keyword">float</span> viewDistance, <span class="keyword">bool</span> usePhysics2D</span>)</span></div><div class="line">  &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AudioSource[] <span class="title">GetAudioSources</span>(<span class="params">GameObject target</span>)</span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">bool</span> flag = MovementUtility.transformAudioSourceMap == <span class="literal">null</span>;</div><div class="line">    <span class="keyword">if</span> (flag)</div><div class="line">    &#123;</div><div class="line">      MovementUtility.transformAudioSourceMap = <span class="keyword">new</span> Dictionary&lt;GameObject, AudioSource[]&gt;();</div><div class="line">    &#125;</div><div class="line">    AudioSource[] componentsInChildren;</div><div class="line">    <span class="keyword">bool</span> flag2 = MovementUtility.transformAudioSourceMap.TryGetValue(target, <span class="keyword">out</span> componentsInChildren);</div><div class="line">    AudioSource[] result;</div><div class="line">    <span class="keyword">if</span> (flag2)</div><div class="line">    &#123;</div><div class="line">      result = componentsInChildren;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      componentsInChildren = target.GetComponentsInChildren&lt;AudioSource&gt;();</div><div class="line">      MovementUtility.transformAudioSourceMap.Add(target, componentsInChildren);</div><div class="line">      result = componentsInChildren;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GameObject <span class="title">LineOfSight</span>(<span class="params">Transform transform, Vector3 positionOffset, GameObject targetObject, Vector3 targetOffset, <span class="keyword">bool</span> usePhysics2D, <span class="keyword">int</span> ignoreLayerMask</span>)</span></div><div class="line">  &#123;</div><div class="line">    GameObject result;</div><div class="line">    <span class="keyword">if</span> (usePhysics2D)</div><div class="line">    &#123;</div><div class="line">      RaycastHit2D raycastHit2D;</div><div class="line">      <span class="keyword">bool</span> flag = raycastHit2D = Physics2D.Linecast(transform.TransformPoint(positionOffset), targetObject.transform.TransformPoint(targetOffset), ~ignoreLayerMask);</div><div class="line">      <span class="keyword">if</span> (flag)</div><div class="line">      &#123;</div><div class="line">        <span class="keyword">bool</span> flag2 = raycastHit2D.transform.IsChildOf(targetObject.transform) || targetObject.transform.IsChildOf(raycastHit2D.transform);</div><div class="line">        <span class="keyword">if</span> (flag2)</div><div class="line">        &#123;</div><div class="line">          result = targetObject;</div><div class="line">          <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      RaycastHit raycastHit;</div><div class="line"></div><div class="line">      <span class="keyword">bool</span> flag3 = Physics.Linecast(transform.TransformPoint(positionOffset), targetObject.transform.TransformPoint(targetOffset), <span class="keyword">out</span> raycastHit, ~ignoreLayerMask);</div><div class="line">      <span class="keyword">if</span> (flag3)</div><div class="line">      &#123;</div><div class="line">        <span class="keyword">bool</span> flag4 = raycastHit.transform.IsChildOf(targetObject.transform) || targetObject.transform.IsChildOf(raycastHit.transform);</div><div class="line">        <span class="keyword">if</span> (flag4)</div><div class="line">        &#123;</div><div class="line">          result = targetObject;</div><div class="line">          <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    result = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GameObject <span class="title">WithinHearingRange2D</span>(<span class="params">Transform transform, Vector3 positionOffset, <span class="keyword">float</span> audibilityThreshold, <span class="keyword">float</span> hearingRadius, LayerMask objectLayerMask</span>)</span></div><div class="line">  &#123;</div><div class="line">    GameObject result = <span class="literal">null</span>;</div><div class="line">    Collider2D[] array = Physics2D.OverlapCircleAll(transform.TransformPoint(positionOffset), hearingRadius, objectLayerMask);</div><div class="line">    <span class="keyword">bool</span> flag = array != <span class="literal">null</span>;</div><div class="line">    <span class="keyword">if</span> (flag)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">float</span> num = <span class="number">0</span>f;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.Length; i++)</div><div class="line">      &#123;</div><div class="line">        <span class="keyword">float</span> num2 = <span class="number">0</span>f;</div><div class="line">        GameObject gameObject;</div><div class="line">        <span class="keyword">bool</span> flag2 = (gameObject = MovementUtility.WithinHearingRange(transform, positionOffset, audibilityThreshold, array[i].gameObject, <span class="keyword">ref</span> num2)) != <span class="literal">null</span>;</div><div class="line">        <span class="keyword">if</span> (flag2)</div><div class="line">        &#123;</div><div class="line">          <span class="keyword">bool</span> flag3 = num2 &gt; num;</div><div class="line">          <span class="keyword">if</span> (flag3)</div><div class="line">          &#123;</div><div class="line">            num = num2;</div><div class="line">            result = gameObject;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GameObject <span class="title">WithinSight</span>(<span class="params">Transform transform, Vector3 positionOffset, <span class="keyword">float</span> fieldOfViewAngle, <span class="keyword">float</span> viewDistance, LayerMask objectLayerMask, Vector3 targetOffset, LayerMask ignoreLayerMask</span>)</span></div><div class="line">  &#123;</div><div class="line">    GameObject result = <span class="literal">null</span>;</div><div class="line">    Collider[] array = Physics.OverlapSphere(transform.position, viewDistance, objectLayerMask);</div><div class="line">    <span class="keyword">bool</span> flag = array != <span class="literal">null</span>;</div><div class="line">    <span class="keyword">if</span> (flag)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">float</span> num = <span class="keyword">float</span>.PositiveInfinity;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.Length; i++)</div><div class="line">      &#123;</div><div class="line">        <span class="keyword">float</span> num2;</div><div class="line">        GameObject gameObject;</div><div class="line">        <span class="keyword">bool</span> flag2 = (gameObject = MovementUtility.WithinSight(transform, positionOffset, fieldOfViewAngle, viewDistance, array[i].gameObject, targetOffset, <span class="literal">false</span>, <span class="number">0</span>f, <span class="keyword">out</span> num2, ignoreLayerMask)) != <span class="literal">null</span>;</div><div class="line">        <span class="keyword">if</span> (flag2)</div><div class="line">        &#123;</div><div class="line">          <span class="keyword">bool</span> flag3 = num2 &lt; num;</div><div class="line">          <span class="keyword">if</span> (flag3)</div><div class="line">          &#123;</div><div class="line">            num = num2;</div><div class="line">            result = gameObject;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GameObject <span class="title">WithinSight</span>(<span class="params">Transform transform, Vector3 positionOffset, <span class="keyword">float</span> fieldOfViewAngle, <span class="keyword">float</span> viewDistance, GameObject targetObject, Vector3 targetOffset, LayerMask ignoreLayerMask</span>)</span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">float</span> num;</div><div class="line">    <span class="keyword">return</span> MovementUtility.WithinSight(transform, positionOffset, fieldOfViewAngle, viewDistance, targetObject, targetOffset, <span class="literal">false</span>, <span class="number">0</span>f, <span class="keyword">out</span> num, ignoreLayerMask);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> GameObject <span class="title">WithinSight</span>(<span class="params">Transform transform, Vector3 positionOffset, <span class="keyword">float</span> fieldOfViewAngle, <span class="keyword">float</span> viewDistance, GameObject targetObject, Vector3 targetOffset, <span class="keyword">bool</span> usePhysics2D, <span class="keyword">float</span> angleOffset2D, <span class="keyword">out</span> <span class="keyword">float</span> angle, <span class="keyword">int</span> ignoreLayerMask</span>)</span></div><div class="line">  &#123;</div><div class="line">    Vector3 vector = targetObject.transform.position - transform.TransformPoint(positionOffset);</div><div class="line">    <span class="keyword">if</span> (usePhysics2D)</div><div class="line">    &#123;</div><div class="line">      angle = Vector3.Angle(vector, transform.up) + angleOffset2D;</div><div class="line">      vector.z = <span class="number">0</span>f;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      angle = Vector3.Angle(vector, transform.forward);</div><div class="line">      vector.y = <span class="number">0</span>f;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">bool</span> flag = vector.magnitude &lt; viewDistance &amp;&amp; angle &lt; fieldOfViewAngle * <span class="number">0.5</span>f;</div><div class="line">    GameObject result;</div><div class="line">    <span class="keyword">if</span> (flag)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">bool</span> flag2 = MovementUtility.LineOfSight(transform, positionOffset, targetObject, targetOffset, usePhysics2D, ignoreLayerMask) != <span class="literal">null</span>;</div><div class="line">      <span class="keyword">if</span> (flag2)</div><div class="line">      &#123;</div><div class="line">        result = targetObject;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">bool</span> flag3 = targetObject.GetComponent&lt;Collider&gt;() == <span class="literal">null</span> &amp;&amp; targetObject.GetComponent&lt;Collider2D&gt;() == <span class="literal">null</span>;</div><div class="line">      <span class="keyword">if</span> (flag3)</div><div class="line">      &#123;</div><div class="line">        <span class="keyword">bool</span> activeSelf = targetObject.gameObject.activeSelf;</div><div class="line">        <span class="keyword">if</span> (activeSelf)</div><div class="line">        &#123;</div><div class="line">          result = targetObject;</div><div class="line">          <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    result = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GameObject <span class="title">WithinSight2D</span>(<span class="params">Transform transform, Vector3 positionOffset, <span class="keyword">float</span> fieldOfViewAngle, <span class="keyword">float</span> viewDistance, LayerMask objectLayerMask, Vector3 targetOffset, <span class="keyword">float</span> angleOffset2D, LayerMask ignoreLayerMask</span>)</span></div><div class="line">  &#123;</div><div class="line">    GameObject result = <span class="literal">null</span>;</div><div class="line">    Collider2D[] array = Physics2D.OverlapCircleAll(transform.position, viewDistance, objectLayerMask);</div><div class="line">    <span class="keyword">bool</span> flag = array != <span class="literal">null</span>;</div><div class="line">    <span class="keyword">if</span> (flag)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">float</span> num = <span class="keyword">float</span>.PositiveInfinity;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.Length; i++)</div><div class="line">      &#123;</div><div class="line">        <span class="keyword">float</span> num2;</div><div class="line">        GameObject gameObject;</div><div class="line">        <span class="keyword">bool</span> flag2 = (gameObject = MovementUtility.WithinSight(transform, positionOffset, fieldOfViewAngle, viewDistance, array[i].gameObject, targetOffset, <span class="literal">true</span>, angleOffset2D, <span class="keyword">out</span> num2, ignoreLayerMask)) != <span class="literal">null</span>;</div><div class="line">        <span class="keyword">if</span> (flag2)</div><div class="line">        &#123;</div><div class="line">          <span class="keyword">bool</span> flag3 = num2 &lt; num;</div><div class="line">          <span class="keyword">if</span> (flag3)</div><div class="line">          &#123;</div><div class="line">            num = num2;</div><div class="line">            result = gameObject;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GameObject <span class="title">WithinSight2D</span>(<span class="params">Transform transform, Vector3 positionOffset, <span class="keyword">float</span> fieldOfViewAngle, <span class="keyword">float</span> viewDistance, GameObject targetObject, Vector3 targetOffset, <span class="keyword">float</span> angleOffset2D, LayerMask ignoreLayerMask</span>)</span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">float</span> num;</div><div class="line">    <span class="keyword">return</span> MovementUtility.WithinSight(transform, positionOffset, fieldOfViewAngle, viewDistance, targetObject, targetOffset, <span class="literal">true</span>, angleOffset2D, <span class="keyword">out</span> num, ignoreLayerMask);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;分享一个技围检测脚本，用来判定范围内是否有目标，或者是线性范围内是否可见目标。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/uploads/ScreenShot2017-12-17.png&quot; alt=&quot;简洁范围检测&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="UNITY3D" scheme="http://vrast.cn/categories/UNITY3D/"/>
    
    
      <category term="Physics" scheme="http://vrast.cn/tags/Physics/"/>
    
  </entry>
  
  <entry>
    <title>解决NavmeshAgent寻路边界的判定</title>
    <link href="http://vrast.cn/posts/e53ade9f/"/>
    <id>http://vrast.cn/posts/e53ade9f/</id>
    <published>2017-12-15T14:36:00.000Z</published>
    <updated>2017-12-22T14:26:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>今天群里有兄弟问: “我看到navmeshagent里面有个方法叫什么获取网格边缘点的，我打算首先判断目标点在不在网格上。在的话正常逻辑，不在的话判断当前agent的位置有没有到那个边缘点 “ 。我想这样应该能解决这个问题。</p>
</blockquote>
<p><img src="/uploads/FC9B64C1057D31F1B4692EF0EC22A08B.jpg" alt="解决边界点的判定"></p>
<a id="more"></a>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">1</span>))</div><div class="line">&#123;</div><div class="line">    NavMeshHit hit;</div><div class="line">    NavMesh.Raycast(transform.position, target.position, <span class="keyword">out</span> hit, <span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (hit.hit)</div><div class="line">    &#123;</div><div class="line">        NavMeshPath path = <span class="keyword">new</span> NavMeshPath();</div><div class="line">        <span class="keyword">if</span> (agent.CalculatePath(hit.position, path))</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">var</span> pos = path.corners[path.corners.Length - <span class="number">1</span>];</div><div class="line">            <span class="keyword">var</span> o = GameObject.CreatePrimitive(PrimitiveType.Sphere);</div><div class="line">            o.transform.localScale = Vector3.one * <span class="number">0.1</span>f;</div><div class="line">            o.transform.position = pos;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今天群里有兄弟问: “我看到navmeshagent里面有个方法叫什么获取网格边缘点的，我打算首先判断目标点在不在网格上。在的话正常逻辑，不在的话判断当前agent的位置有没有到那个边缘点 “ 。我想这样应该能解决这个问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/uploads/FC9B64C1057D31F1B4692EF0EC22A08B.jpg&quot; alt=&quot;解决边界点的判定&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="UNITY3D" scheme="http://vrast.cn/categories/UNITY3D/"/>
    
    
      <category term="NavmeshAgent" scheme="http://vrast.cn/tags/NavmeshAgent/"/>
    
  </entry>
  
  <entry>
    <title>High-level NavMesh Building Components</title>
    <link href="http://vrast.cn/posts/98dfcd51/"/>
    <id>http://vrast.cn/posts/98dfcd51/</id>
    <published>2017-12-07T12:49:15.000Z</published>
    <updated>2017-12-08T03:10:38.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>高级 NavMesh 组件说明文档</p>
</blockquote>
<p>NavMesh Surface 脚本 ，在此之前 我看了网络上的一篇介绍 <a href="http://forum.china.unity3d.com/thread-25421-1-1.html" target="_blank" rel="external">进击的新版NavMesh系统：看我飞檐走壁</a> 效果非常好。我一边测试一边记录关于Surface的用法。</p>
<p>NavMesh Surcefa组件表示特定NavMeshAgent类型的可行走区域，并定义应该构建NavMesh的场景的一部分。</p>
<p>NavMesh Surface组件不在标准Unity安装中; 有关如何访问它的信息，<a href="https://docs.unity3d.com/Manual/class-NavMeshSurface.html" target="_blank" rel="external">请参阅高级NavMesh构建组件的文档</a>。</p>
<p>要使用NavMesh Surface组件，导航到GameObject&gt; AI&gt; NavMesh Surface。 这将创建一个空的GameObject，并附带一个NavMesh Surface组件。 一个场景可以包含多个NavMesh表面。</p>
<a id="more"></a>
<p><img src="/uploads/class-NavMeshSurface-0.png" alt="嗯 就是这货了"></p>
<p><img src="/uploads/QQ20171207-161002@2x.png" alt="针对与这个组件的使用说明"></p>
<p><img src="/uploads/QQ20171207-162319.png" alt="NavMesh Surface参数说明"></p>
<blockquote>
<p>NavMesh Off-Link &amp;  Off-mesh-Link 我们通常用第一种。在两个不可行走区域之间 使用跨越点+动画 实现定点跳跃。</p>
</blockquote>
<p><img src="/uploads/QQ20171207-194954.png" alt="Off Link"><br><img src="/uploads/QQ20171207-195557.png" alt="Off Link"></p>
<blockquote>
<p>NavMesh Modifier &amp; NavMesh Modifier Volume 在烘培之前修改区域是否行走</p>
</blockquote>
<p>先说 NavMesh Modifier volume,你可以在烘培之前选定区域设置区域类型，例子将某个Agent设置成该区域不能行走。</p>
<p><img src="/uploads/class-NavMesh-ModifierVolume-4.png" alt="NavMesh Modifier Volume效果图"></p>
<!-- more -->
<p><img src="/uploads/QQ20171207-193142@2x.png" alt="NavMesh Modifier Volume使用方法"></p>
<p>如果知道了 NavMesh Modifier Volume 那么可以猜得到  NavMesh Modifier 就是给附着这个脚本的mesh上的区域设置区域类型。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;高级 NavMesh 组件说明文档&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;NavMesh Surface 脚本 ，在此之前 我看了网络上的一篇介绍 &lt;a href=&quot;http://forum.china.unity3d.com/thread-25421-1-1.html&quot;&gt;进击的新版NavMesh系统：看我飞檐走壁&lt;/a&gt; 效果非常好。我一边测试一边记录关于Surface的用法。&lt;/p&gt;
&lt;p&gt;NavMesh Surcefa组件表示特定NavMeshAgent类型的可行走区域，并定义应该构建NavMesh的场景的一部分。&lt;/p&gt;
&lt;p&gt;NavMesh Surface组件不在标准Unity安装中; 有关如何访问它的信息，&lt;a href=&quot;https://docs.unity3d.com/Manual/class-NavMeshSurface.html&quot;&gt;请参阅高级NavMesh构建组件的文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;要使用NavMesh Surface组件，导航到GameObject&amp;gt; AI&amp;gt; NavMesh Surface。 这将创建一个空的GameObject，并附带一个NavMesh Surface组件。 一个场景可以包含多个NavMesh表面。&lt;/p&gt;
    
    </summary>
    
      <category term="UNITY3D" scheme="http://vrast.cn/categories/UNITY3D/"/>
    
    
      <category term="Navigation" scheme="http://vrast.cn/tags/Navigation/"/>
    
  </entry>
  
  <entry>
    <title>Building a NavMesh</title>
    <link href="http://vrast.cn/posts/33160c87/"/>
    <id>http://vrast.cn/posts/33160c87/</id>
    <published>2017-12-07T05:50:59.000Z</published>
    <updated>2017-12-07T08:58:46.123Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>创建导航网格与Unity2017面板详细参数说明。</p>
</blockquote>
<a id="more"></a>
<h1 id="创建Navmesh-与-Agent-设置"><a href="#创建Navmesh-与-Agent-设置" class="headerlink" title="创建Navmesh 与 Agent 设置"></a>创建Navmesh 与 Agent 设置</h1><p><img src="/uploads/NavMeshSetupObject.svg" alt="设置网格"></p>
<p><img src="/uploads/NavMeshSetupBake.svg" alt="设置网格烘焙"></p>
<blockquote>
<p>一些你需要知道的参数</p>
</blockquote>
<ul>
<li>Agent半径定义了Agentd的中心可以靠近墙壁或窗台的距离。</li>
<li><p>Agent Radius defines how close the agent center can get to a wall or a ledge.</p>
</li>
<li><p>Agent高度定义Agent可以到达的空间有多低。</p>
</li>
<li><p>Agent Height defines how low the spaces are that the agent can reach.</p>
</li>
<li><p>最大坡度定义了Agent人走上坡道的坡度。</p>
</li>
<li><p>Max Slope defines how steep the ramps are that the agent walk up.</p>
</li>
<li><p>台阶高度定义了Agent可以踩踏的障碍物的高度。</p>
</li>
<li>Step Height defines how high obstructions are that the agent can step on.</li>
</ul>
<p><img src="/uploads/NavMeshAsset.svg" alt="烘培好的网格会在Scene的同名目录内"></p>
<blockquote>
<p>Navmesh bake 高级烘焙设置</p>
</blockquote>
<h1 id="Min-Region-Area"><a href="#Min-Region-Area" class="headerlink" title="Min Region Area"></a>Min Region Area</h1><p><img src="/uploads/NavMeshMinRegion.svg" alt="最小烘焙区域，最小区域高级构建设置允许您清除小的未连接的NavMesh区域。 比表面积小于指定值的NavMesh区域将被移除。"></p>
<h1 id="更小的代理半径"><a href="#更小的代理半径" class="headerlink" title="更小的代理半径"></a>更小的代理半径</h1><p>Voxel Size<br><img src="/uploads/QQ20171207-143312@2x.png" alt="体素尺寸"></p>
<p>手动更改体素允许您更改烘烤过程的准确性。</p>
<p>NavMesh烘焙过程使用体素化从任意级别的几何构建NavMesh。 在算法的第一遍中，场景被光栅化成体素，然后提取步行表面，最后将步进表面变成导航网格。 体素大小描述了由此产生的NavMesh如何准确地表示场景几何。</p>
<p>默认精度设置为每个Agent半径有3个体素，即整个Agent宽度为6个体素。 这是精度和烘烤速度之间的良好折衷。 将体素大小减半会使内存使用量增加4倍，而构建场景需要花费4倍的时间。</p>
<p>NavMesh烘烤系统也将减小体素的大小。 如果您的其他Agent维度保持不变，则可能不需要增加NavMesh构建分辨率。</p>
<p>最简单的方法如下：</p>
<p>将Agent半径设置为实际Agent半径。<br>打开手动体素大小，这将采取当前体素大小和“冻结”。<br>手动设置更小的Agent半径，因为您已经选中了手动体素大小，体素大小不会改变。</p>
<h1 id="更精确的NavMesh"><a href="#更精确的NavMesh" class="headerlink" title="更精确的NavMesh"></a>更精确的NavMesh</h1><p>如果你的关卡有很多紧凑的点，你可能希望通过缩小体素来提高准确性。 体素大小下的标签显示体素大小和代理半径之间的关系。 一个合理的范围是2-8之间，进一步缩小体素比通常会导致非常长的构建时间。</p>
<p>当您在游戏中有意建造走廊时，请注意，除了代理人半径之外，您还应该至少保留4 * 像素大小的空间，尤其是在走廊处于角度的情况下。<br>如果您需要小于NavMesh烘烤支持的走廊，请考虑使用“Off-Link”跨越点。 这些还有额外的好处，可以在使用时检测到，例如可以播放特定的动画。</p>
<p>More Accurate NavMesh</p>
<p>If your level has a lot of tight spots, you may want to increase the accuracy by making the voxel smaller. The label under the Voxel Size shows the relation between the voxel size and Agent Radius. A good range is something between 2–8, going further than that generally results really long build times.</p>
<p>When you intentionally build tight corridors in your game, please note that you should leave at least 4 * voxelSize clearance in addition to the agent radius, especially if the corridors are at angles.</p>
<p>If you need smaller corridors than the NavMesh baking can support, please consider using Off-Mesh Links. These have the additional benefit that you can detect when they are being used and can, for example, play a specific animation.</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;创建导航网格与Unity2017面板详细参数说明。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="UNITY3D" scheme="http://vrast.cn/categories/UNITY3D/"/>
    
    
      <category term="Navigation" scheme="http://vrast.cn/tags/Navigation/"/>
    
  </entry>
  
  <entry>
    <title>Navigation System In Unity</title>
    <link href="http://vrast.cn/posts/671463f1/"/>
    <id>http://vrast.cn/posts/671463f1/</id>
    <published>2017-12-07T02:50:56.000Z</published>
    <updated>2017-12-07T08:08:03.795Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>时间仓促，大部分采用google机器翻译来不及全部校对翻译成中文资料 本篇作为笔记。感兴趣的可以看下。这篇是记录Unity3D寻路的官方文档阅读体验。</p>
</blockquote>
<p>The Navigation System allows you to create characters which can navigate the game world. It gives your characters the ability to understand that they need to take stairs to reach second floor, or to jump to get over a ditch. The Unity NavMesh system consists of the following pieces:</p>
<p>Unity3d的寻路系统大概有下面几个部分：</p>
<p>NavMesh（导航网格的缩写）是描述游戏世界的步行表面的数据结构，并且允许从游戏世界中的一个步行位置到另一个步行路径找到路径。 数据结构是烘焙的网格里获取的。</p>
<p>NavMesh (short for Navigation Mesh) is a data structure which describes the walkable surfaces of the game world and allows to find path from one walkable location to another in the game world. The data structure is built, or baked, automatically from your level geometry.</p>
<p>NavMesh Agent组件帮助您创建角色，在向目标移动时避开彼此。Agent使用NavMesh理解游戏世界，他们知道如何避免彼此以及移动障碍物。<br>离网链接组件允许您合并无法使用可走行的曲面表示的导航快捷方式。 例如，跳过沟渠或栅栏，或者在走过它之前打开门，都可以被描述为“Off-mesh”链接。</p>
<p>NavMesh Agent component help you to create characters which avoid each other while moving towards their goal. Agents reason about the game world using the NavMesh and they know how to avoid each other as well as moving obstacles.<br>Off-Mesh Link component allows you to incorporate navigation shortcuts which cannot be represented using a walkable surface. For example, jumping over a ditch or a fence, or opening a door before walking through it, can be all described as Off-mesh links.</p>
<p>NavMesh障碍组件允许您描述Agent在航行世界时应避免的移动障碍。 物理系统控制的一个桶或一个箱子是一个障碍的好例子。 当障碍物移动时，障碍物尽力避开它，但是一旦障碍物变得静止，它将在导航网上挖一个洞，使得障碍物可以改变它们的路径来绕过障碍物，或者如果障碍物妨碍路径 方式，Agent可以找到不同的路线。</p>
<p>NavMesh Obstacle component allows you to describe moving obstacles the agents should avoid while navigating the world. A barrel or a crate controlled by the physics system is a good example of an obstacle. While the obstacle is moving the agents do their best to avoid it, but once the obstacle becomes stationary it will carve a hole in the navmesh so that the agents can change their paths to steer around it, or if the stationary obstacle is blocking the path way, the agents can find a different route.</p>
<a id="more"></a>
<h1 id="Inner-Workings-of-the-Navigation-System-Navigation的工作原理"><a href="#Inner-Workings-of-the-Navigation-System-Navigation的工作原理" class="headerlink" title="Inner Workings of the Navigation System / Navigation的工作原理"></a>Inner Workings of the Navigation System / Navigation的工作原理</h1><p>当你想智能地移动你的游戏中的角色（或者在AI圈子中被称为Agent）时，你必须解决两个问题：如何推理关卡以找到目的地，然后如何移动到那里。 这两个问题紧密结合在一起，但性质却截然不同。 关于层次的推理问题更加全局化和静态化，因为它考虑了整个场景。 移动到目的地更具局部性和动态性，只考虑移动的方向，以及如何防止与其他移动Agent发生冲突。</p>
<p>When you want to intelligently move characters in your game (or agents as they are called in AI circles), you have to solve two problems: how to reason about the level to find the destination, then how to move there. These two problems are tightly coupled, but quite different in nature. The problem of reasoning about the level is more global and static, in that it takes into account the whole scene. Moving to the destination is more local and dynamic, it only considers the direction to move and how to prevent collisions with other moving agents.</p>
<p><img src="/uploads/NavMeshUnderstandingAreas.png" alt="可行走区域"></p>
<p>导航系统需要自己的数据来表示游戏场景中的可行走区域。 步行区域定义了Agent可以站立和移动的场景中的地点。 在Unity中，Agent被描述为圆柱体。 通过测试Agent站点的位置，可以从场景中的几何结构自动建立可行走区域。 然后，位置连接到场景几何图形上的表面。 这个表面被称为导航网格（简称NavMesh）。</p>
<p>The navigation system needs its own data to represent the walkable areas in a game scene. The walkable areas define the places in the scene where the agent can stand and move. In Unity the agents are described as cylinders. The walkable area is built automatically from the geometry in the scene by testing the locations where the agent can stand. Then the locations are connected to a surface laying on top of the scene geometry. This surface is called the navigation mesh (NavMesh for short).</p>
<p>NavMesh将这个曲面存储为凸多边形。 凸多边形是一个有用的表示，因为我们知道多边形内的任意两点之间没有障碍物。 除了多边形边界之外，我们还存储有关哪些多边形是彼此相邻的信息。 这使我们能够推断整个步行区域。</p>
<p>The NavMesh stores this surface as convex polygons. Convex polygons are a useful representation, since we know that there are no obstructions between any two points inside a polygon. In addition to the polygon boundaries, we store information about which polygons are neighbours to each other. This allows us to reason about the whole walkable area.</p>
<p><img src="/uploads/NavMeshUnderstandingPath.png" alt="寻路"></p>
<p>要查找场景中两个位置之间的路径，我们首先需要将起始位置和目标位置映射到最近的多边形。 然后我们从开始位置开始搜索，访问所有邻居，直到到达目的地多边形。 跟踪访问的多边形允许我们找到从开始到目的地的多边形序列。 寻找路径的常见算法是Unity <em>使用的A </em>（发音为“A star”）。</p>
<p>To find path between two locations in the scene, we first need to map the start and destination locations to their nearest polygons. Then we start searching from the start location, visiting all the neighbours until we reach the destination polygon. Tracing the visited polygons allows us to find the sequence of polygons which will lead from the start to the destination. A common algorithm to find the path is A* (pronounced “A star”), which is what Unity uses.</p>
<p><img src="/uploads/NavMeshUnderstandingCorridor.png" alt="跟随路径"></p>
<p>描述从开始到目的地多边形路径的多边形序列称为走廊。 Agent将通过总是转向走廊的下一个可见角落而到达目的地。 如果你有一个简单的游戏，只有一个Agent在场景中移动，那么一次性找到走廊的所有角落并使角色沿连接角的线段移动是很好的。</p>
<p>The sequence of polygons which describe the path from the start to the destination polygon is called a corridor. The agent will reach the destination by always steering towards the next visible corner of the corridor. If you have a simple game where only one agent moves in the scene, it is fine to find all the corners of the corridor in one swoop and animate the character to move along the line segments connecting the corners.</p>
<p>在处理同时移动的多个Agent时，他们需要在避开对方时偏离原来的路径。 尝试使用由线段组成的路径来纠正这种偏差变得非常困难且容易出错。</p>
<p>When dealing with multiple agents moving at the same time, they will need to deviate from the original path when avoiding each other. Trying to correct such deviations using a path consisting of line segments soon becomes very difficult and error prone.</p>
<p><img src="/uploads/NavMeshUnderstandingMove.png" alt="Navmesh理解移动方式"></p>
<p>由于每个框架内的Agent移动都很小，所以我们可以利用多边形的连通性来固定走廊，我们需要绕行。 然后我们很快找到下一个可见的角落转向。<br>Since the agent movement in each frame is quite small, we can use the connectivity of the polygons to fix up the corridor in case we need to take a little detour. Then we quickly find the next visible corner to steer towards.</p>
<h1 id="Avoiding-Obstacles-规避障碍"><a href="#Avoiding-Obstacles-规避障碍" class="headerlink" title="Avoiding Obstacles / 规避障碍"></a>Avoiding Obstacles / 规避障碍</h1><p><img src="/uploads/NavMeshUnderstandingAvoid.png" alt="NavMesh理解规避"></p>
<p>转向逻辑取下一个角的位置，并根据这个数字找出到达目的地所需的方向和速度（或速度）。 使用所需的速度移动Agent可能会导致与其他Agent发生冲突。</p>
<p>The steering logic takes the position of the next corner and based on that figures out a desired direction and speed (or velocity) needed to reach the destination. Using the desired velocity to move the agent can lead to collision with other agents.</p>
<p>障碍规避选择新的速度，该速度在向期望的方向移动和防止将来与其他Agent和导航网格的边缘的碰撞之间平衡。 Unity使用交互的度障碍（RVO）来预测和防止碰撞。<br>Obstacle avoidance chooses a new velocity which balances between moving in the desired direction and preventing future collisions with other agents and edges of the navigation mesh. Unity is using reciprocal velocity obstacles (RVO) to predict and prevent collisions.</p>
<h1 id="Moving-the-Agent-移动Agent"><a href="#Moving-the-Agent-移动Agent" class="headerlink" title="Moving the Agent / 移动Agent"></a>Moving the Agent / 移动Agent</h1><p>最后在转向和避障后计算最终速度。 在Unity中，Agent使用简单的动态模型进行模拟，该模型还考虑了加速度，以便更自然，更流畅地移动。<br>Finally after steering and obstacle avoidance the final velocity is calculated. In Unity the agents are simulated using a simple dynamic model, which also takes into account acceleration to allow more natural and smooth movement.</p>
<p>在这个阶段，可以将模拟Agent的速度提供给Mecanim动画系统，以移动角色，或者让导航系统处理。<br>At this stage it is possible to feed the velocity from the simulated agent to the Mecanim animation system to move the character, or let the navigation system take care of that.</p>
<p>一旦使用任一方法移动Agent，模拟的Agent位置将被移动，并被限制在NavMesh内。 这最后一小步对于强大的导航非常重要。<br>Once the agent has been moved using either method, the simulated agent location is moved and constrained to NavMesh. This last small step is important for robust navigation.</p>
<h1 id="Global-and-Local"><a href="#Global-and-Local" class="headerlink" title="Global and Local"></a>Global and Local</h1><p><img src="/uploads/NavMeshUnderstandingLoop.png" alt="理解Navmesh的循环"></p>
<p>关于导航最重要的事情之一是全局导航和本地导航之间的区别。</p>
<p>One of the most important things to understand about navigation is the difference between global and local navigation.</p>
<p>全局导航是用来查找全局各地的走廊。 在全局范围内寻找路径是一项代价高昂的操作，需要相当多的处理能力和内存。</p>
<p>Global navigation is used to find the corridor across the world. Finding a path across the world is a costly operation requiring quite a lot of processing power and memory.</p>
<p>描述路径的多边形的线性列表是用于转向的灵活的数据结构，并且可以随着Agent的位置移动而在本地调整。 本地(Local)导航试图找出如何有效地移动到下一个角落，而不会与其他Agent或移动对象发生冲突。</p>
<p>The linear list of polygons describing the path is a flexible data structure for steering, and it can be locally adjusted as the agent’s position moves. Local navigation tries to figure out how to efficiently move towards the next corner without colliding with other agents or moving objects.</p>
<h1 id="Two-Cases-for-Obstacles-两个障碍案例"><a href="#Two-Cases-for-Obstacles-两个障碍案例" class="headerlink" title="Two Cases for Obstacles / 两个障碍案例"></a>Two Cases for Obstacles / 两个障碍案例</h1><p>导航的许多应用需要其他类型的障碍，而不仅仅是其他Agent。 这些可能是射击游戏或车辆中常见的箱子和桶。 障碍物可以通过局部避障或全局寻路来处理。</p>
<p>Many applications of navigation require other types of obstacles rather than just other agents. These could be the usual crates and barrels in a shooter game, or vehicles. The obstacles can be handled using local obstacle avoidance or global pathfinding.</p>
<p>当障碍物移动时，最好使用避免局部障碍物来处理。 这样Agent可以预测性地避免障碍。 当障碍物静止时，可以考虑阻挡所有Agent人的路径，障碍物应该影响全局导航，即导航网格。</p>
<p>When an obstacle is moving, it is best handled using local obstacles avoidance. This way the agent can predictively avoid the obstacle. When the obstacle becomes stationary, and can be considered to block the path of all agents, the obstacles should affect the global navigation, that is, the navigation mesh.</p>
<p>改变NavMesh被称为雕刻(carving)。 该过程检测障碍物的哪些部分接触NavMesh并将孔雕刻到NavMesh中。 这在计算上是昂贵的操作，这又是另一个令人信服的原因，为什么移动障碍物应该使用避免碰撞来处理。</p>
<p>Changing the NavMesh is called carving. The process detects which parts of the obstacle touches the NavMesh and carves holes into the NavMesh. This is computationally expensive operation, which is yet another compelling reason, why moving obstacles should be handled using collision avoidance.</p>
<h1 id="Describing-Off-mesh-Links-关于Off-mesh（跨网格链接）"><a href="#Describing-Off-mesh-Links-关于Off-mesh（跨网格链接）" class="headerlink" title="Describing Off-mesh Links / 关于Off-mesh（跨网格链接）"></a>Describing Off-mesh Links / 关于Off-mesh（跨网格链接）</h1><p><img src="/uploadsNavMeshUnderstandingOffmesh.png" alt="理解offmesh"></p>
<p>NavMesh多边形之间的连接使用路径查找系统内的链接进行描述。 有时需要让Agent人跨越不可行走的地方，例如跳过围栏或穿过关闭的门。 这些案件需要知道行动的地点。</p>
<p>The connections between the NavMesh polygons are described using links inside the pathfinding system. Sometimes it is necessary to let the agent to navigate across places which are not walkable, for example, jumping over a fence, or traversing through a closed door. These cases need to know the location of the action.</p>
<p>这些动作可以使用Off-Mesh链接进行注释，通过指定的链接告诉探路者路线存在。 这个链接可以在路径后面访问，并且可以执行特殊的动作。</p>
<p>These actions can be annotated using Off-Mesh Links which tell the pathfinder that a route exists through the specified link. This link can be later accessed when following the path, and the special action can be executed.</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;时间仓促，大部分采用google机器翻译来不及全部校对翻译成中文资料 本篇作为笔记。感兴趣的可以看下。这篇是记录Unity3D寻路的官方文档阅读体验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The Navigation System allows you to create characters which can navigate the game world. It gives your characters the ability to understand that they need to take stairs to reach second floor, or to jump to get over a ditch. The Unity NavMesh system consists of the following pieces:&lt;/p&gt;
&lt;p&gt;Unity3d的寻路系统大概有下面几个部分：&lt;/p&gt;
&lt;p&gt;NavMesh（导航网格的缩写）是描述游戏世界的步行表面的数据结构，并且允许从游戏世界中的一个步行位置到另一个步行路径找到路径。 数据结构是烘焙的网格里获取的。&lt;/p&gt;
&lt;p&gt;NavMesh (short for Navigation Mesh) is a data structure which describes the walkable surfaces of the game world and allows to find path from one walkable location to another in the game world. The data structure is built, or baked, automatically from your level geometry.&lt;/p&gt;
&lt;p&gt;NavMesh Agent组件帮助您创建角色，在向目标移动时避开彼此。Agent使用NavMesh理解游戏世界，他们知道如何避免彼此以及移动障碍物。&lt;br&gt;离网链接组件允许您合并无法使用可走行的曲面表示的导航快捷方式。 例如，跳过沟渠或栅栏，或者在走过它之前打开门，都可以被描述为“Off-mesh”链接。&lt;/p&gt;
&lt;p&gt;NavMesh Agent component help you to create characters which avoid each other while moving towards their goal. Agents reason about the game world using the NavMesh and they know how to avoid each other as well as moving obstacles.&lt;br&gt;Off-Mesh Link component allows you to incorporate navigation shortcuts which cannot be represented using a walkable surface. For example, jumping over a ditch or a fence, or opening a door before walking through it, can be all described as Off-mesh links.&lt;/p&gt;
&lt;p&gt;NavMesh障碍组件允许您描述Agent在航行世界时应避免的移动障碍。 物理系统控制的一个桶或一个箱子是一个障碍的好例子。 当障碍物移动时，障碍物尽力避开它，但是一旦障碍物变得静止，它将在导航网上挖一个洞，使得障碍物可以改变它们的路径来绕过障碍物，或者如果障碍物妨碍路径 方式，Agent可以找到不同的路线。&lt;/p&gt;
&lt;p&gt;NavMesh Obstacle component allows you to describe moving obstacles the agents should avoid while navigating the world. A barrel or a crate controlled by the physics system is a good example of an obstacle. While the obstacle is moving the agents do their best to avoid it, but once the obstacle becomes stationary it will carve a hole in the navmesh so that the agents can change their paths to steer around it, or if the stationary obstacle is blocking the path way, the agents can find a different route.&lt;/p&gt;
    
    </summary>
    
      <category term="UNITY3D" scheme="http://vrast.cn/categories/UNITY3D/"/>
    
    
      <category term="Navigation" scheme="http://vrast.cn/tags/Navigation/"/>
    
  </entry>
  
  <entry>
    <title>Unity3D 自动化测试</title>
    <link href="http://vrast.cn/posts/1d932b40/"/>
    <id>http://vrast.cn/posts/1d932b40/</id>
    <published>2017-12-05T16:33:39.000Z</published>
    <updated>2018-01-03T08:33:32.286Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>今天凌晨开始写这篇文章，想写这个主题很久了。相信每个资深开发都经历过每次公司要发版本之前都会有一堆bug闪现。真让人苦恼。很高兴 Unity technology 于 今年的六一儿童节更新了自动化测试的特性。这下终于不用再导入第三方自动化测试插件了。当然本章节会相对完整的快速概述其重要部分。如果你还想知道更多, Unity3D 已经提供了比较完善的<a href="https://docs.unity3d.com/Manual/testing-editortestsrunner.html" target="_blank" rel="external">文档</a>。</p>
</blockquote>
<a id="more"></a>
<h1 id="适用于多种平台的自动化测试"><a href="#适用于多种平台的自动化测试" class="headerlink" title="适用于多种平台的自动化测试"></a>适用于多种平台的自动化测试</h1><p>TestRunner 适用于 Standalone, Android, or iOS 等平台。你可以在 Window &gt; Test Runner 找到此项功能。</p>
<p>TestRunner 使用了Unity一体化的单元测试库。开源的.net语言库。更多的信息在 <a href="http://nunit.org" target="_blank" rel="external">nunit 官网</a> 和 <a href="https://github.com/nunit/docs/wiki/NUnit-Documentation" target="_blank" rel="external">NUnit GitHub文档</a>.</p>
<p>UnityTestAttribute是Unity Test Runner的标准NUnit库的主要补充。 这是一种单元测试，允许您从测试中跳过框架（允许后台任务完成）。 当以编辑模式运行时，以Play模式运行并在EditorApplication.update回调循环中执行UnityTestAttribute作为协同程序。</p>
<h1 id="已知问题和限制"><a href="#已知问题和限制" class="headerlink" title="已知问题和限制"></a>已知问题和限制</h1><p>以下是Unity Test Runner的已知问题和局限性：</p>
<p>WebGL和WSA平台不支持UnityTestAttribute。<br>测试运行者目前不支持AOT平台。<br>UnityTest不支持参数化测试（ValueSource除外）。<br>在命令行运行的平台播放器（例如Standalone，Android或iOS）中的自动测试目前不受支持。<br>在进行EditMode测试时，您必须创建一个文件夹名称编辑器来存储它们。</p>
<p><img src="/uploads/TestRunner3.png" alt="面板参数"></p>
<p><img src="/uploads/TestRunner5.png" alt="开启与关闭测试"></p>
<h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><h2 id="Test-与-UnityTest-特性"><a href="#Test-与-UnityTest-特性" class="headerlink" title="Test 与 UnityTest 特性"></a>Test 与 UnityTest 特性</h2><p>在编辑器或者运行状态下都可以使用Test<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[Test]</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GameObject_CreatedWithGiven_WillHaveTheName</span>(<span class="params"></span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">var</span> go = <span class="keyword">new</span> GameObject(<span class="string">"MyGameObject"</span>);</div><div class="line">    Assert.AreEqual(“MyGameObject”, go.name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在运行状态下使用UnityTest<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[UnityTest]</div><div class="line"><span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GameObject_WithRigidBody_WillBeAffectedByPhysics</span>(<span class="params"></span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">var</span> go = <span class="keyword">new</span> GameObject();</div><div class="line">    go.AddComponent&lt;Rigidbody&gt;();</div><div class="line">    <span class="keyword">var</span> originalPosition = go.transform.position.y;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">yield</span> return new <span class="title">WaitForFixedUpdate</span>(<span class="params"></span>)</span>;</div><div class="line"></div><div class="line">    Assert.AreNotEqual(originalPosition, go.transform.position.y);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在编辑器下使用<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[UnityTest]</div><div class="line"><span class="function"><span class="keyword">public</span> IEnumerator <span class="title">EditorUtility_WhenExecuted_ReturnsSuccess</span>(<span class="params"></span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">var</span> utility = RunEditorUtilityInTheBackgroud();</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (utility.isRunning)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Assert.IsTrue(utility.isSuccess);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="UnityPlatform-特性"><a href="#UnityPlatform-特性" class="headerlink" title="UnityPlatform 特性"></a>UnityPlatform 特性</h2><p>该特性可以帮助你区分测试的平台<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[Test]</div><div class="line">[UnityPlatform (RuntimePlatform.WindowsPlayer)]</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestMethod1</span>(<span class="params"></span>)</span></div><div class="line">&#123;</div><div class="line">   Assert.AreEqual(Application.platform, RuntimePlatform.WindowsPlayer);</div><div class="line">&#125;</div><div class="line"></div><div class="line">[Test]</div><div class="line">[UnityPlatform(exclude = <span class="keyword">new</span>[] &#123;RuntimePlatform.WindowsEditor &#125;)]</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestMethod2</span>(<span class="params"></span>)</span></div><div class="line">&#123;</div><div class="line">   Assert.AreNotEqual(Application.platform, RuntimePlatform.WindowsEditor);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="PrebuildSetup"><a href="#PrebuildSetup" class="headerlink" title="PrebuildSetup"></a>PrebuildSetup</h2><p>如果您需要在测试开始之前执行任何额外的设置，请使用PrebuildSetupAttribute。 为此，请指定实现IPrebuildSetup接口的类类型。 如果您需要运行整个类的设置代码（例如，如果您想在测试开始之前执行一些代码，例如特定测试所需的资源准备或设置），请在类中实现IPrebuildSetup接口以进行测试。</p>
<p>只需要继承 IPrebuildSetup 接口 并且 标记 PrebuildSetup 特性就能提前配置单元测试所需数据或者资源。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestsWithPrebuildStep</span> : <span class="title">IPrebuildSetup</span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Setup</span>(<span class="params"></span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// Run this code before the tests are executed</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [Test]</div><div class="line">    <span class="comment">//PrebuildSetupAttribute can be skipped because it's implemented in the same class</span></div><div class="line">    [PrebuildSetup(<span class="keyword">typeof</span>(TestsWithPrebuildStep))]</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></div><div class="line">    &#123;</div><div class="line">        (...)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在进入播放模式或建立播放器之前，执行PrebuildSetup代码。 安装程序可以使用UnityEditor命名空间及其功能，但为了避免编译错误，您必须将其放置在“editor”文件夹中，或者必须使用#if UNITY_EDITOR指令进行保护。</p>
<h2 id="LogAssert-Log断言"><a href="#LogAssert-Log断言" class="headerlink" title="LogAssert Log断言"></a>LogAssert Log断言</h2><p>如果记录除常规日志或警告消息之外的其他消息，则测试将失败。 使用LogAssert类在日志中预期消息，并防止测试失败。<br>如果预期的消息没有出现，测试也报告失败。 如果任何常规的日志或警告消息不出现，测试也失败。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[Test]</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LogAssertExample</span>(<span class="params"></span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//Expect a regular log message</span></div><div class="line">    LogAssert.Expect(LogType.Log, <span class="string">"Log message"</span>);</div><div class="line">    <span class="comment">//A log message is expected so without the following line</span></div><div class="line">    <span class="comment">//the test would fail</span></div><div class="line">    Debug.Log(<span class="string">"Log message"</span>);</div><div class="line">    <span class="comment">//An error log is printed</span></div><div class="line">    Debug.LogError(<span class="string">"Error message"</span>);</div><div class="line">    <span class="comment">//Without expecting an error log, the test would fail</span></div><div class="line">    LogAssert.Expect(LogType.Error, <span class="string">"Error message"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="MonoBehaviourTest-Mono脚本测试"><a href="#MonoBehaviourTest-Mono脚本测试" class="headerlink" title="MonoBehaviourTest Mono脚本测试"></a>MonoBehaviourTest Mono脚本测试</h2><p>MonoBehaviourTest是编写MonoBehaviour测试的包装，也是一个协程。 从UnityTest中产生MonoBehaviourTest来实例化指定的MonoBehaviour并等待它完成执行。 实现IMonoBehaviourTest接口来指示测试完成的时间。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">[UnityTest]</div><div class="line">public IEnumerator MonoBehaviourTest_Works()</div><div class="line">&#123;</div><div class="line">    yield return new MonoBehaviourTest&lt;MyMonoBehaviourTest&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class MyMonoBehaviourTest : MonoBehaviour, IMonoBehaviourTest</div><div class="line">&#123;</div><div class="line">    private int frameCount;</div><div class="line">    public bool IsTestFinished</div><div class="line">    &#123;</div><div class="line">        get &#123; return frameCount &gt; 10; &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     void Update()</div><div class="line">     &#123;</div><div class="line">        frameCount++;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ol>
<li>所有标记  UnityTestAttribute  特性的方法 测试的时候就像是协同程序一样被执行。</li>
<li>待续 。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今天凌晨开始写这篇文章，想写这个主题很久了。相信每个资深开发都经历过每次公司要发版本之前都会有一堆bug闪现。真让人苦恼。很高兴 Unity technology 于 今年的六一儿童节更新了自动化测试的特性。这下终于不用再导入第三方自动化测试插件了。当然本章节会相对完整的快速概述其重要部分。如果你还想知道更多, Unity3D 已经提供了比较完善的&lt;a href=&quot;https://docs.unity3d.com/Manual/testing-editortestsrunner.html&quot;&gt;文档&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="UNITY3D" scheme="http://vrast.cn/categories/UNITY3D/"/>
    
    
      <category term="测试自动化" scheme="http://vrast.cn/tags/%E6%B5%8B%E8%AF%95%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Git FAQ</title>
    <link href="http://vrast.cn/posts/1e42cd7e/"/>
    <id>http://vrast.cn/posts/1e42cd7e/</id>
    <published>2017-12-02T12:37:23.000Z</published>
    <updated>2017-12-03T02:19:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天有朋友问了我三个问题：</p>
<ul>
<li>策划或者美术可能没有commit前先pull的习惯，先commit上去，然后push不上。Git提醒pull，然后报错，一般除了程序，甚至没使用过Git的程序就有点不知所措了。应该要讲下出错时候要stash的问题。</li>
<li>策划pull出错时候， 万一revert，然后push强推,把之前别人提交的东西冲掉了。我们有用过回滚，然后强推上去。可以再讲下怎么强推</li>
<li>怎么stash，怎么stash apply，apply失败后怎么弄。commit的顺序最好也要重点强调下</li>
</ul>
<p>在篇中我会解答，如果还有其他问题 请给我留言，我会追加叙述。求关注 求转发。把爱传出去 笑～</p>
<a id="more"></a>
<h1 id="在解答第一个问题之前我们先了解一下什么是-stash-存储-非程序人员跳过此条说明"><a href="#在解答第一个问题之前我们先了解一下什么是-stash-存储-非程序人员跳过此条说明" class="headerlink" title="在解答第一个问题之前我们先了解一下什么是 stash (存储) (非程序人员跳过此条说明)"></a>在解答第一个问题之前我们先了解一下什么是 stash (存储) (非程序人员跳过此条说明)</h1><p><a href="https://stackoverflow.com/questions/10959928/what-does-commit-your-changes-or-stash-them-mean#10959956" target="_blank" rel="external">What does “commit your changes or stash them” mean?</a></p>
<p>stash意味着你有未提交的更改，将会在拉取代码的时候防止本地的修改被覆盖。顺便说一句如果你想知道更多关于Git stash 的问题只需要提问：how do I solve the problem where Git tells me to commit or stash (如何解决Git告诉我commit或stash的问题)</p>
<p>通过git stash将工作区恢复到上次提交的内容，同时备份本地所做的修改，之后就可以正常git pull了，git pull完成后，执行git stash pop将之前本地做的修改应用到当前工作区。</p>
<p>git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。<br>git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。<br>git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。<br>git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。</p>
<h1 id="Pull-与-Fetch-区别-基本概念"><a href="#Pull-与-Fetch-区别-基本概念" class="headerlink" title="Pull 与 Fetch 区别 (基本概念)"></a>Pull 与 Fetch 区别 (基本概念)</h1><ol>
<li>每次commit都会有一个记录。</li>
<li>本地的所有commit在没有push之前，都是存在本地。别人是更新不到你的commit记录的。</li>
<li>所谓更新就是拿到别人的Commit数据。</li>
<li>如果你更新到别人的commit里也有你本次commit修改的数据 就会产生冲突，就需要合并。</li>
<li>Pull 的意思是 下载比自己更新的commit数据，并且开始合并，可能马上就有从冲突文件。</li>
<li>Fetch 的意思是 下载比自己更新的commit数据，放在那里(不合并到当前commit)，可以看看是否有必要更新到最近commit。</li>
</ol>
<h1 id="先解释下报错信息"><a href="#先解释下报错信息" class="headerlink" title="先解释下报错信息"></a>先解释下报错信息</h1><p>你本地的修改和Git存储上的冲突了，现在有两种方式来解决：</p>
<ol>
<li>commit 先提交本地的修改，commit的原因是为了可追溯，通过本地branches就能拿到N+1个版本的修改。防止丢失</li>
<li>stash 备份本地的修改 ，仍旧是防止丢失，且可以有多个版本 很灵活</li>
</ol>
<h2 id="演示-Stash如何使用-规避文件修改被冲掉"><a href="#演示-Stash如何使用-规避文件修改被冲掉" class="headerlink" title="演示-Stash如何使用 规避文件修改被冲掉"></a>演示-Stash如何使用 规避文件修改被冲掉</h2><p>我们假设有两个人正在操作同一份文件 <code>README.md</code> 。<br>A君 : 我已经提交此文件的修改了，你更新下。<br>B君 : 我先Fetch看看有，然后我上传。嗯？冲突了。我并不知道你修改了什么个文件,我也不想在同步的时候把本地的修改冲掉。 那我提前 <code>Stash</code> 这些个文件吧。</p>
<p><img src="/uploads/gulpfile.png" alt="机制的B君做了如下操作"><br><img src="/uploads/QQ20171202-213806@2x.png" alt="Stash了勾选后的将本地修改在这里"></p>
<p>B君 : 点击<apply stash=""> 可将指定的Stash文件与更新后的文件合并。</apply></p>
<blockquote>
<h2>Stash 简单理解就是备份本地修改,且可以备份多次。什么?又冲突了？用Stash啊！</h2>


</blockquote>
<h2 id="演示-使用commit来规避文件修改被冲掉"><a href="#演示-使用commit来规避文件修改被冲掉" class="headerlink" title="演示-使用commit来规避文件修改被冲掉"></a>演示-使用commit来规避文件修改被冲掉</h2><p>我们假设有两个人正在操作同一份文件 <code>README.md</code> 。<br>A君 : 我已经提交此文件的修改了，你更新下。<br>B君 : 我先Fetch看看有，然后我上传。嗯？冲突了。我并不知道你修改了什么个文件,我也不想在同步的时候把本地的修改冲掉。 那我提前 <code>commit</code> 这些个文件吧。</p>
<p><img src="/uploads/1040FC64-815A-4DD3-B703-52AD31B022D0.png" alt="这个Push Change不用勾选，反正勾选也上传不了但是不影响commit。"><br><img src="/uploads/A2A598E1-86FF-4380-A3CE-FFE532E83E0D.png" alt="现在pull也可以合并本地文件"></p>
<blockquote>
<h2>commit 简单理解就是保存本次修改,且可以被追溯。什么你只会Stash？直接commit也行啊！</h2>




</blockquote>
<h1 id="如何强推？"><a href="#如何强推？" class="headerlink" title="如何强推？"></a>如何强推？</h1><p>理解了上面的之后。发现 用Stash 或者Commit都可以实现强推。</p>
<p><img src="/uploads/BDCE2D9F-7600-48C7-9528-1FFCC155445C.png" alt="现在commit肯定不行 因为被修改过了，sourcetree的机制是 点击按钮 默认commit，然后push"></p>
<p><img src="/uploads/QQ20171202-223641.png" alt="必然是失败的，点击OK,现在本地branch已经有了此次commit痕迹了(可追溯)"></p>
<p>现在点击pull/或者Apply Stash 处理好，上传吧。</p>
<h1 id="出了莫名其妙的问题如何补救？"><a href="#出了莫名其妙的问题如何补救？" class="headerlink" title="出了莫名其妙的问题如何补救？"></a>出了莫名其妙的问题如何补救？</h1><p>有些朋友一看到一堆报错和本地紊乱的修改就慌了。别怕 可以直接回到存档(commit)点去复活。</p>
<p><img src="/uploads/A56FB26C-1A89-4106-BC16-9D41A9114255.png" alt="直接回到某个commit的状态"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天有朋友问了我三个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;策划或者美术可能没有commit前先pull的习惯，先commit上去，然后push不上。Git提醒pull，然后报错，一般除了程序，甚至没使用过Git的程序就有点不知所措了。应该要讲下出错时候要stash的问题。&lt;/li&gt;
&lt;li&gt;策划pull出错时候， 万一revert，然后push强推,把之前别人提交的东西冲掉了。我们有用过回滚，然后强推上去。可以再讲下怎么强推&lt;/li&gt;
&lt;li&gt;怎么stash，怎么stash apply，apply失败后怎么弄。commit的顺序最好也要重点强调下&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在篇中我会解答，如果还有其他问题 请给我留言，我会追加叙述。求关注 求转发。把爱传出去 笑～&lt;/p&gt;
    
    </summary>
    
      <category term="FAQ" scheme="http://vrast.cn/categories/FAQ/"/>
    
    
      <category term="Git" scheme="http://vrast.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Rounded Cube 5</title>
    <link href="http://vrast.cn/posts/710804c5/"/>
    <id>http://vrast.cn/posts/710804c5/</id>
    <published>2017-11-25T15:59:47.000Z</published>
    <updated>2017-11-25T16:08:32.204Z</updated>
    
    <content type="html"><![CDATA[<p>接上回 Rounded Cube 4.本章主题如下:</p>
<ul>
<li>Combine primitive colliders. 合并原始网格</li>
</ul>
<p>此为本人阅读笔记不作为转载处理,详细还请参看原文. <a href="http://catlikecoding.com/unity/tutorials/" target="_blank" rel="external">原文地址</a><br><a id="more"></a></p>
<p>圆滑的立方体碰撞并不是圆滑的，所以就有了本章节来解决这个问题。添加如下方法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Generate</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    GetComponent&lt;MeshFilter&gt;().mesh = mesh = <span class="keyword">new</span> Mesh();</div><div class="line">    mesh.name = <span class="string">"Procedural Cube"</span>;</div><div class="line">    CreateVertices();</div><div class="line">    CreateTriangles();</div><div class="line">    CreateColliders();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateColliders</span> (<span class="params"></span>) </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一步添加一个cube碰撞器<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateColliders</span> (<span class="params"></span>) </span>&#123;</div><div class="line">		gameObject.AddComponent&lt;BoxCollider&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/uploads/07-one-collider.png" alt="单个盒子碰撞器"></p>
<p>事实证明，Unity足够智能的定位和缩放碰撞器，使其与我们网格的边界框匹配。 现在，我们必须缩放碰撞器，使其与两个相对面的平坦侧面相匹配。 由于这三个面对都需要完成，我们最终得到三个相交的块。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateColliders</span> (<span class="params"></span>) </span>&#123;</div><div class="line">		AddBoxCollider(xSize, ySize - roundness * <span class="number">2</span>, zSize - roundness * <span class="number">2</span>);</div><div class="line">		AddBoxCollider(xSize - roundness * <span class="number">2</span>, ySize, zSize - roundness * <span class="number">2</span>);</div><div class="line">		AddBoxCollider(xSize - roundness * <span class="number">2</span>, ySize - roundness * <span class="number">2</span>, zSize);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddBoxCollider</span> (<span class="params"><span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z</span>) </span>&#123;</div><div class="line">		BoxCollider c = gameObject.AddComponent&lt;BoxCollider&gt;();</div><div class="line">		c.size = <span class="keyword">new</span> Vector3(x, y, z);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><img src="/uploads/07-box-colliders.png" alt="平坦区域的盒子碰撞"></p>
<p>我们可以用胶囊来填充棱角。我们需要给他们正确的方向，把他们定位在每一个边缘的中心。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddCapsuleCollider</span> (<span class="params"><span class="keyword">int</span> direction, <span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z</span>) </span>&#123;</div><div class="line">		CapsuleCollider c = gameObject.AddComponent&lt;CapsuleCollider&gt;();</div><div class="line">		c.center = <span class="keyword">new</span> Vector3(x, y, z);</div><div class="line">		c.direction = direction;</div><div class="line">		c.radius = roundness;</div><div class="line">		c.height = c.center[direction] * <span class="number">2</span>f;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>我们每边需要一个胶囊，总共有十二个胶囊。 我创建了最小，最大和最大的矢量，以使放置更容易。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateColliders</span> (<span class="params"></span>) </span>&#123;</div><div class="line">		AddBoxCollider(xSize, ySize - roundness * <span class="number">2</span>, zSize - roundness * <span class="number">2</span>);</div><div class="line">		AddBoxCollider(xSize - roundness * <span class="number">2</span>, ySize, zSize - roundness * <span class="number">2</span>);</div><div class="line">		AddBoxCollider(xSize - roundness * <span class="number">2</span>, ySize - roundness * <span class="number">2</span>, zSize);</div><div class="line"></div><div class="line">		Vector3 min = Vector3.one * roundness;</div><div class="line">		Vector3 half = <span class="keyword">new</span> Vector3(xSize, ySize, zSize) * <span class="number">0.5</span>f; </div><div class="line">		Vector3 max = <span class="keyword">new</span> Vector3(xSize, ySize, zSize) - min;</div><div class="line"></div><div class="line">		AddCapsuleCollider(<span class="number">0</span>, half.x, min.y, min.z);</div><div class="line">		AddCapsuleCollider(<span class="number">0</span>, half.x, min.y, max.z);</div><div class="line">		AddCapsuleCollider(<span class="number">0</span>, half.x, max.y, min.z);</div><div class="line">		AddCapsuleCollider(<span class="number">0</span>, half.x, max.y, max.z);</div><div class="line">		</div><div class="line">		AddCapsuleCollider(<span class="number">1</span>, min.x, half.y, min.z);</div><div class="line">		AddCapsuleCollider(<span class="number">1</span>, min.x, half.y, max.z);</div><div class="line">		AddCapsuleCollider(<span class="number">1</span>, max.x, half.y, min.z);</div><div class="line">		AddCapsuleCollider(<span class="number">1</span>, max.x, half.y, max.z);</div><div class="line">		</div><div class="line">		AddCapsuleCollider(<span class="number">2</span>, min.x, min.y, half.z);</div><div class="line">		AddCapsuleCollider(<span class="number">2</span>, min.x, max.y, half.z);</div><div class="line">		AddCapsuleCollider(<span class="number">2</span>, max.x, min.y, half.z);</div><div class="line">		AddCapsuleCollider(<span class="number">2</span>, max.x, max.y, half.z);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p><img src="/uploads/07-all-colliders.png" alt="为接下来的动作做准备"></p>
<p>剩下要做的就是在圆角立方体上加一个刚体，恭喜你，看完了本章教程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接上回 Rounded Cube 4.本章主题如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Combine primitive colliders. 合并原始网格&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此为本人阅读笔记不作为转载处理,详细还请参看原文. &lt;a href=&quot;http://catlikecoding.com/unity/tutorials/&quot;&gt;原文地址&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="翻译" scheme="http://vrast.cn/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="UNITY3D" scheme="http://vrast.cn/tags/UNITY3D/"/>
    
  </entry>
  
  <entry>
    <title>Rounded Cube 4</title>
    <link href="http://vrast.cn/posts/60f3453/"/>
    <id>http://vrast.cn/posts/60f3453/</id>
    <published>2017-11-25T15:13:25.000Z</published>
    <updated>2017-11-25T16:09:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>接上回 Rounded Cube 3.本章主题如下:</p>
<ul>
<li>Create a custom shader. 使用自定义shader</li>
</ul>
<p>此为本人阅读笔记不作为转载处理,详细还请参看原文. <a href="http://catlikecoding.com/unity/tutorials/" target="_blank" rel="external">原文地址</a><br><a id="more"></a></p>
<p>虽然我们现在可以区分面，但我们仍然没有纹理坐标。 假设我们想在整个立方体上显示一个网格模式，以便我们可以看到单个四边形。 我们怎样才能做到这一点？</p>
<p><img src="/uploads/06-grid-texture.png" alt="贴图(纹理)覆盖四边形"></p>
<p>我们可以使用自定义着色器来找出如何应用纹理，而不是将UV坐标存储在网格中。 这是一个刚创建的着色器。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">Shader <span class="string">"Custom/Rounded Cube Grid"</span> &#123;</div><div class="line">	Properties &#123;</div><div class="line">		_Color (<span class="string">"Color"</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">		_MainTex (<span class="string">"Albedo (RGB)"</span>, <span class="number">2</span>D) = <span class="string">"white"</span> &#123;&#125;</div><div class="line">		_Glossiness (<span class="string">"Smoothness"</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></div><div class="line">		_Metallic (<span class="string">"Metallic"</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.0</span></div><div class="line">	&#125;</div><div class="line">	SubShader &#123;</div><div class="line">		Tags &#123; <span class="string">"RenderType"</span>=<span class="string">"Opaque"</span> &#125;</div><div class="line">		LOD <span class="number">200</span></div><div class="line">		</div><div class="line">		CGPROGRAM</div><div class="line">		<span class="meta">#<span class="meta-keyword">pragma</span> surface surf Standard fullforwardshadows</span></div><div class="line">		<span class="meta">#<span class="meta-keyword">pragma</span> target 3.0</span></div><div class="line"></div><div class="line">		sampler2D _MainTex;</div><div class="line"></div><div class="line">		<span class="keyword">struct</span> Input &#123;</div><div class="line">			float2 uv_MainTex;</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		half _Glossiness;</div><div class="line">		half _Metallic;</div><div class="line">		fixed4 _Color;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">void</span> <span class="title">surf</span> (<span class="params">Input IN, inout SurfaceOutputStandard o</span>) </span>&#123;</div><div class="line">			fixed4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color;</div><div class="line">			o.Albedo = c.rgb;</div><div class="line">			o.Metallic = _Metallic;</div><div class="line">			o.Smoothness = _Glossiness;</div><div class="line">			o.Alpha = c.a;</div><div class="line">		&#125;</div><div class="line">		ENDCG</div><div class="line">	&#125; </div><div class="line">	FallBack <span class="string">"Diffuse"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是默认的表面着色器。 重要的是它定义了一个输入结构，它要求主纹理的坐标。 这些坐标在surf函数中使用，为每个渲染片段调用。 由于我们没有这样的坐标，我们必须用其他的东西替换uv_MainTex。– Google这段翻译的真好</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Input &#123;</div><div class="line">        float2 cubeUV;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    …</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">surf</span> (<span class="params">Input IN, inout SurfaceOutputStandard o</span>) </span>&#123;</div><div class="line">        fixed4 c = tex2D(_MainTex, IN.cubeUV) * _Color;</div><div class="line">        o.Albedo = c.rgb;</div><div class="line">        o.Metallic = _Metallic;</div><div class="line">        o.Smoothness = _Glossiness;</div><div class="line">        o.Alpha = c.a;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于每个顶点定义了UV，所以我们必须添加一个每个顶点调用的函数。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">CGPROGRAM</div><div class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> surface surf Standard fullforwardshadows vertex:vert</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> target 3.0</span></div><div class="line"></div><div class="line">    sampler2D _MainTex;</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> Input &#123;</div><div class="line">        float2 cubeUV;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    half _Glossiness;</div><div class="line">    half _Metallic;</div><div class="line">    fixed4 _Color;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">vert</span> (<span class="params">inout appdata_full v, <span class="keyword">out</span> Input o</span>) </span>&#123;</div><div class="line">        UNITY_INITIALIZE_OUTPUT(Input, o);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">surf</span> (<span class="params">Input IN, inout SurfaceOutputStandard o</span>) </span>&#123;</div><div class="line">        fixed4 c = tex2D(_MainTex, IN.cubeUV) * _Color;</div><div class="line">        o.Albedo = c.rgb;</div><div class="line">        o.Metallic = _Metallic;</div><div class="line">        o.Smoothness = _Glossiness;</div><div class="line">        o.Alpha = c.a;</div><div class="line">    &#125;</div><div class="line">ENDCG</div></pre></td></tr></table></figure>
<p>为了检查我们的着色器是否工作，直接使用顶点位置的XY坐标作为UV。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">vert</span> (<span class="params">inout appdata_full v, <span class="keyword">out</span> Input o</span>) </span>&#123;</div><div class="line">        UNITY_INITIALIZE_OUTPUT(Input, o);</div><div class="line">        o.cubeUV = v.vertex.xy;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><img src="/uploads/06-grid-xy.png" alt="使用xy作为UV"><br><img src="/uploads/06-material-x.png" alt="使用xy作为UV"></p>
<p>这对于Z面来说是合理的，但其他的却是一团糟。 我们需要为它们使用不同的顶点坐标。 所以我们有一个选择，我们可以通过添加关键字枚举着色器属性来支持。</p>
<blockquote>
<p>这里划重点了 使用关键枚举来决定渲染不同的面，背后的工作原理是：枚举对应的宏定义</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Properties &#123;</div><div class="line">    _Color (<span class="string">"Color"</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">    _MainTex (<span class="string">"Albedo (RGB)"</span>, <span class="number">2</span>D) = <span class="string">"white"</span> &#123;&#125;</div><div class="line">    _Glossiness (<span class="string">"Smoothness"</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></div><div class="line">    _Metallic (<span class="string">"Metallic"</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.0</span></div><div class="line">    [KeywordEnum(X, Y, Z)] _Faces (<span class="string">"Faces"</span>, Float) = <span class="number">0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以通过定义关键字义，使我们能够为每个选项编写不同的代码。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">vert</span> (<span class="params">inout appdata_full v, <span class="keyword">out</span> Input o</span>) </span>&#123;</div><div class="line">			UNITY_INITIALIZE_OUTPUT(Input, o);</div><div class="line">			<span class="meta">#<span class="meta-keyword">if</span> defined(_FACES_X)</span></div><div class="line">				o.cubeUV = v.vertex.yz;</div><div class="line">			<span class="meta">#<span class="meta-keyword">elif</span> defined(_FACES_Y)</span></div><div class="line">				o.cubeUV = v.vertex.xz;</div><div class="line">			<span class="meta">#<span class="meta-keyword">elif</span> defined(_FACES_Z)</span></div><div class="line">				o.cubeUV = v.vertex.xy;</div><div class="line">			<span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p><img src="/uploads/06-grid-faces.png" alt="每种材质使用不同的坐标"></p>
<p>刚开始看起来不错，但网格线不适合实际四边形。 更糟糕的是，当我们使用世界空间顶点位置时，移动或旋转立方体时会变得很奇怪。</p>
<p>在四舍五入之前，我们需要原始立方体的顶点位置。 如果我们可以将它们存储在网格中，我们可以将它们传递给着色器。 由于我们不使用顶点颜色，因此我们可以使用顶点颜色通道来达到此目的。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Color32[] cubeUV;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateVertices</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">int</span> cornerVertices = <span class="number">8</span>;</div><div class="line">    <span class="keyword">int</span> edgeVertices = (xSize + ySize + zSize - <span class="number">3</span>) * <span class="number">4</span>;</div><div class="line">    <span class="keyword">int</span> faceVertices = (</div><div class="line">        (xSize - <span class="number">1</span>) * (ySize - <span class="number">1</span>) +</div><div class="line">        (xSize - <span class="number">1</span>) * (zSize - <span class="number">1</span>) +</div><div class="line">        (ySize - <span class="number">1</span>) * (zSize - <span class="number">1</span>)) * <span class="number">2</span>;</div><div class="line">    vertices = <span class="keyword">new</span> Vector3[cornerVertices + edgeVertices + faceVertices];</div><div class="line">    normals = <span class="keyword">new</span> Vector3[vertices.Length];</div><div class="line">    cubeUV = <span class="keyword">new</span> Color32[vertices.Length];</div><div class="line"></div><div class="line">    …</div><div class="line"></div><div class="line">    mesh.vertices = vertices;</div><div class="line">    mesh.normals = normals;</div><div class="line">    mesh.colors32 = cubeUV;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetVertex</span> (<span class="params"><span class="keyword">int</span> i, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z</span>) </span>&#123;</div><div class="line">    …</div><div class="line"></div><div class="line">    normals[i] = (vertices[i] - inner).normalized;</div><div class="line">    vertices[i] = inner + normals[i] * roundness;</div><div class="line">    cubeUV[i] = <span class="keyword">new</span> Color32((<span class="keyword">byte</span>)x, (<span class="keyword">byte</span>)y, (<span class="keyword">byte</span>)z, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们必须使用Color32来代替通常的Color类型，因为顶点颜色组件被存储为单个字节。 整个颜色是四个字节，与单个浮点大小相同。</p>
<p>如果我们使用常规颜色，那么Unity将从0-1浮点数转换为0-255字节，截断该范围之外的所有内容。 通过直接转换为字节，我们可以处理多达255的多维数据集，这应该是足够的。</p>
<p>在着色器方面，我们现在可以使用顶点颜色而不是其位置。 当着色器将顶点颜色通道解释为0-1范围内的值时，我们必须通过乘以255来撤消此转换。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">vert</span> (<span class="params">inout appdata_full v, <span class="keyword">out</span> Input o</span>) </span>&#123;</div><div class="line">    UNITY_INITIALIZE_OUTPUT(Input, o);</div><div class="line">    <span class="meta">#<span class="meta-keyword">if</span> defined(_FACES_X)</span></div><div class="line">        o.cubeUV = v.color.yz * <span class="number">255</span>;</div><div class="line">    <span class="meta">#<span class="meta-keyword">elif</span> defined(_FACES_Y)</span></div><div class="line">        o.cubeUV = v.color.xz * <span class="number">255</span>;</div><div class="line">    <span class="meta">#<span class="meta-keyword">elif</span> defined(_FACES_Z)</span></div><div class="line">        o.cubeUV = v.color.xy * <span class="number">255</span>;</div><div class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/uploads/06-grid-cube.png" alt="网格使用原始立方体位置"></p>
<p>我们终于有了一个功能性的网格纹理。 请注意，每对面之一的UV坐标是镜像的，但这不是重点，因为我们使用的是对称纹理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接上回 Rounded Cube 3.本章主题如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Create a custom shader. 使用自定义shader&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此为本人阅读笔记不作为转载处理,详细还请参看原文. &lt;a href=&quot;http://catlikecoding.com/unity/tutorials/&quot;&gt;原文地址&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="翻译" scheme="http://vrast.cn/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="UNITY3D" scheme="http://vrast.cn/tags/UNITY3D/"/>
    
  </entry>
  
  <entry>
    <title>Rounded Cube 3</title>
    <link href="http://vrast.cn/posts/986ba1f0/"/>
    <id>http://vrast.cn/posts/986ba1f0/</id>
    <published>2017-11-25T14:56:00.000Z</published>
    <updated>2017-11-25T16:08:32.205Z</updated>
    
    <content type="html"><![CDATA[<p>接上回 Rounded Cube 2.本章主题如下:</p>
<ul>
<li>Use sub-meshes. 使用子网格</li>
<li>Create a custom shader. 使用自定义shader</li>
<li>Combine primitive colliders. 合并原始网格</li>
</ul>
<p>此为本人阅读笔记不作为转载处理,详细还请参看原文. <a href="http://catlikecoding.com/unity/tutorials/" target="_blank" rel="external">原文地址</a><br><a id="more"></a></p>
<p>现在我们已经有了一个没有重复顶点的圆滑立方体，现在需要使用多个材质。这时候就需用到子网格。我们把网格分成三对相对的面。 这意味着我们需要三个数组和三个三角形索引。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateTriangles</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] trianglesZ = <span class="keyword">new</span> <span class="keyword">int</span>[(xSize * ySize) * <span class="number">12</span>];</div><div class="line">    <span class="keyword">int</span>[] trianglesX = <span class="keyword">new</span> <span class="keyword">int</span>[(ySize * zSize) * <span class="number">12</span>];</div><div class="line">    <span class="keyword">int</span>[] trianglesY = <span class="keyword">new</span> <span class="keyword">int</span>[(xSize * zSize) * <span class="number">12</span>];</div><div class="line">    <span class="keyword">int</span> ring = (xSize + zSize) * <span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> tZ = <span class="number">0</span>, tX = <span class="number">0</span>, tY = <span class="number">0</span>, v = <span class="number">0</span>;</div><div class="line">    …</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们要把环回路分为四段，在Z和X的数组之间交替。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; ySize; y++, v++) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">0</span>; q &lt; xSize; q++, v++) &#123;</div><div class="line">        tZ = SetQuad(trianglesZ, tZ, v, v + <span class="number">1</span>, v + ring, v + ring + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">0</span>; q &lt; zSize; q++, v++) &#123;</div><div class="line">        tX = SetQuad(trianglesX, tX, v, v + <span class="number">1</span>, v + ring, v + ring + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">0</span>; q &lt; xSize; q++, v++) &#123;</div><div class="line">        tZ = SetQuad(trianglesZ, tZ, v, v + <span class="number">1</span>, v + ring, v + ring + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">0</span>; q &lt; zSize - <span class="number">1</span>; q++, v++) &#123;</div><div class="line">        tX = SetQuad(trianglesX, tX, v, v + <span class="number">1</span>, v + ring, v + ring + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    tX = SetQuad(trianglesX, tX, v, v - ring + <span class="number">1</span>, v + ring, v + <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>顶面和底面只用Y数组。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tY = CreateTopFace(trianglesY, tY, ring);</div><div class="line">tY = CreateBottomFace(trianglesY, tY, ring);</div></pre></td></tr></table></figure>
<p>我们创建三个子网格取代分配mesh.triangles。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mesh.subMeshCount = <span class="number">3</span>;</div><div class="line">mesh.SetTriangles(trianglesZ, <span class="number">0</span>);</div><div class="line">mesh.SetTriangles(trianglesX, <span class="number">1</span>);</div><div class="line">mesh.SetTriangles(trianglesY, <span class="number">2</span>);</div></pre></td></tr></table></figure>
<p><img src="/uploads/05-only-z.png" alt="只展示了两个面"></p>
<p>我们的网格现在被切成三块，只有第一块被实际渲染。 我们必须为网格渲染器分配额外的材质，即每个子网格一个。 这就是为什么有一个材质数组。</p>
<p><img src="/uploads/05-colored-faces.png" alt="三块子网格"><br><img src="/uploads/05-materials.png" alt="一组三材质"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接上回 Rounded Cube 2.本章主题如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use sub-meshes. 使用子网格&lt;/li&gt;
&lt;li&gt;Create a custom shader. 使用自定义shader&lt;/li&gt;
&lt;li&gt;Combine primitive colliders. 合并原始网格&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此为本人阅读笔记不作为转载处理,详细还请参看原文. &lt;a href=&quot;http://catlikecoding.com/unity/tutorials/&quot;&gt;原文地址&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="翻译" scheme="http://vrast.cn/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="UNITY3D" scheme="http://vrast.cn/tags/UNITY3D/"/>
    
  </entry>
  
  <entry>
    <title>Rounded Cube 2</title>
    <link href="http://vrast.cn/posts/ef6c9166/"/>
    <id>http://vrast.cn/posts/ef6c9166/</id>
    <published>2017-11-24T09:35:24.000Z</published>
    <updated>2017-11-25T14:56:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>接上回 Rounded Cube 1.本章主题如下:</p>
<ul>
<li>Define normals. 定义法线</li>
</ul>
<p>此为本人阅读笔记不作为转载处理,详细还请参看原文. <a href="http://catlikecoding.com/unity/tutorials/" target="_blank" rel="external">原文地址</a><br><a id="more"></a></p>
<h1 id="Rounding-the-Cube-圆形方块"><a href="#Rounding-the-Cube-圆形方块" class="headerlink" title="Rounding the Cube 圆形方块"></a>Rounding the Cube 圆形方块</h1><p>先设置一个<code>roundness</code>参数(数值)，并且添加法线字段。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Vector3[] normals;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateVertices</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    …</div><div class="line">    vertices = <span class="keyword">new</span> Vector3[cornerVertices + edgeVertices + faceVertices];</div><div class="line">    normals = <span class="keyword">new</span> Vector3[vertices.Length];</div><div class="line"></div><div class="line">    …</div><div class="line"></div><div class="line">    mesh.vertices = vertices;</div><div class="line">    mesh.normals = normals;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们添加如下方法来计算对于每个顶点的法线<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateVertices</span> (<span class="params"></span>) </span>&#123;</div><div class="line">		…</div><div class="line">    <span class="keyword">int</span> v = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt;= ySize; y++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= xSize; x++) &#123;</div><div class="line">            SetVertex(v++, x, y, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">1</span>; z &lt;= zSize; z++) &#123;</div><div class="line">            SetVertex(v++, xSize, y, z);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = xSize - <span class="number">1</span>; x &gt;= <span class="number">0</span>; x--) &#123;</div><div class="line">            SetVertex(v++, x, y, zSize);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> z = zSize - <span class="number">1</span>; z &gt; <span class="number">0</span>; z--) &#123;</div><div class="line">            SetVertex(v++, <span class="number">0</span>, y, z);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">1</span>; z &lt; zSize; z++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; xSize; x++) &#123;</div><div class="line">            SetVertex(v++, x, ySize, z);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">1</span>; z &lt; zSize; z++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; xSize; x++) &#123;</div><div class="line">            SetVertex(v++, x, <span class="number">0</span>, z);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mesh.vertices = vertices;</div><div class="line">    mesh.normals = normals;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetVertex</span> (<span class="params"><span class="keyword">int</span> i, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z</span>) </span>&#123;</div><div class="line">    vertices[i] = <span class="keyword">new</span> Vector3(x, y, z);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>嗯。然后我们如何定位顶点呢？想象一下一个小一点的cube在原cube内部。这两cube之间的距离等于圆滑程度(值)。你可以想象圆粘在小立方体的角落上，它的半径就等于平滑值，所以内部的cube牢牢的抓住(外部的cube).</p>
<p>对于外部立方体上的任何点，在内部立方体中都有一个最靠近它的点.我们可以用这个来确定圆形cube的法线向量。</p>
<p><img src="/uploads/04-inner-cube.png" alt="想象另外一个立方体在里面"></p>
<p>圆形cube表面的点可以被起始于内部并且沿着法线方向移动的量等于圆滑值的点所达到。 –我的理解<br>圆形立方体的表面点可以从内点开始，沿着法线方向移动，其量等于圆度. – 百度翻译<br>The surface points of the rounded cube can then be found by starting at the inner point and moving along the normal by an amount equal to the roundness. – 原文</p>
<p>下面是参考代码，并未计算出内部的点<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetVertex</span> (<span class="params"><span class="keyword">int</span> i, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z</span>) </span>&#123;</div><div class="line">    Vector3 inner = vertices[i] = <span class="keyword">new</span> Vector3(x, y, z);</div><div class="line"></div><div class="line">    normals[i] = (vertices[i] - inner).normalized;</div><div class="line">    vertices[i] = inner + normals[i] * roundness;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在找到内部的点，开始检查x轴的坐标。如果小于圆滑值就在内部cube的左侧并且在内部x坐标就是简单的圆滑值。如果我们超出了立方体的x大小减去圆滑值，那么我们就在右边。在所有其他情况下，我们在内cube，点共享相同的x坐标范围</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetVertex</span> (<span class="params"><span class="keyword">int</span> i, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z</span>) </span>&#123;</div><div class="line">    Vector3 inner = vertices[i] = <span class="keyword">new</span> Vector3(x, y, z);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (x &lt; roundness) &#123;</div><div class="line">        inner.x = roundness;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">x &gt; xSize - roundness</span>) </span>&#123;</div><div class="line">        inner.x = xSize - roundness;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    normals[i] = (vertices[i] - inner).normalized;</div><div class="line">    vertices[i] = inner + normals[i] * roundness;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/uploads/04-rounded-x.png" alt="一维四舍五入相当平滑"></p>
<p>到目前为止，结果看起来并不圆润，但我们已经在正负X方向上获得了正常值。 对Y坐标进行同样的检查。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (x &lt; roundness) &#123;</div><div class="line">        inner.x = roundness;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">x &gt; xSize - roundness</span>) </span>&#123;</div><div class="line">        inner.x = xSize - roundness;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (y &lt; roundness) &#123;</div><div class="line">        inner.y = roundness;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">y &gt; ySize - roundness</span>) </span>&#123;</div><div class="line">        inner.y = ySize - roundness;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><img src="/uploads/04-rounded-xy.png" alt="在两个纬度上处理圆滑"></p>
<p>现在看起来好点了！ 圆角和法线在XY平面上工作。 剩下的就是检查Z坐标。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (x &lt; roundness) &#123;</div><div class="line">    inner.x = roundness;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">x &gt; xSize - roundness</span>) </span>&#123;</div><div class="line">    inner.x = xSize - roundness;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (y &lt; roundness) &#123;</div><div class="line">    inner.y = roundness;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">y &gt; ySize - roundness</span>) </span>&#123;</div><div class="line">    inner.y = ySize - roundness;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (z &lt; roundness) &#123;</div><div class="line">    inner.z = roundness;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">z &gt; zSize - roundness</span>) </span>&#123;</div><div class="line">    inner.z = zSize - roundness;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/uploads/04-rounded-xyz.png" alt="完全圆滑"></p>
<p>我们终于有了一个完全圆润的立方体。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接上回 Rounded Cube 1.本章主题如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Define normals. 定义法线&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此为本人阅读笔记不作为转载处理,详细还请参看原文. &lt;a href=&quot;http://catlikecoding.com/unity/tutorials/&quot;&gt;原文地址&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="翻译" scheme="http://vrast.cn/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="UNITY3D" scheme="http://vrast.cn/tags/UNITY3D/"/>
    
  </entry>
  
  <entry>
    <title>Rounded Cube 1</title>
    <link href="http://vrast.cn/posts/827b1a39/"/>
    <id>http://vrast.cn/posts/827b1a39/</id>
    <published>2017-11-20T15:47:55.000Z</published>
    <updated>2017-11-24T09:36:56.446Z</updated>
    
    <content type="html"><![CDATA[<p>上一章讲到Mesh的工作原理以及顶点与三角形的算法.本章主题如下:</p>
<ul>
<li>Create a cube with a seamless mesh. 创建无缝Mesh的立方体</li>
<li>Add rounded edges to the cube. 添加圆形边缘的立方体</li>
</ul>
<p>此为本人阅读笔记不作为转载处理,详细还请参看原文. <a href="http://catlikecoding.com/unity/tutorials/" target="_blank" rel="external">原文地址</a><br><a id="more"></a></p>
<h1 id="Compositing-a-Cube-组合-方式-一个立方体"><a href="#Compositing-a-Cube-组合-方式-一个立方体" class="headerlink" title="Compositing a Cube 组合(方式)一个立方体"></a>Compositing a Cube 组合(方式)一个立方体</h1><p>非重点,这里直接写实现思路.接上一章节生产面,只需修改每个面的角度位置.使其拼凑成为一个立方体即可.</p>
<p><img src="/uploads/QQ20170801-152656.png" alt="使用六个面拼凑一个立方体"></p>
<h1 id="Creating-Cube-Vertices-创建立方体的顶点"><a href="#Creating-Cube-Vertices-创建立方体的顶点" class="headerlink" title="Creating Cube Vertices 创建立方体的顶点"></a>Creating Cube Vertices 创建立方体的顶点</h1><h2 id="计算所需定点数量"><a href="#计算所需定点数量" class="headerlink" title="计算所需定点数量"></a>计算所需定点数量</h2><p>之前计算单个面的时候使用 <code>(#x + 1)(#y + 1)</code> 如下算法，那么可计算6个面的时候是不是可以直接套用单面的计算方式：<code>2((#x + 1)(#y + 1) + (#x + 1)(#z + 1) + (#y + 1)(#z + 1))</code> 结论是否定的，其中角顶点与边顶点都被重复计算了。</p>
<p><img src="/uploads/02-vertex-overlap.png" alt="顶点被重复计算次数的用颜色区分"></p>
<p>这其实也不是什么大问题。事实上顶点重复是非常常见的，譬如我们通常用网格创建锐角。所以我们可以创建6个面(的顶点)合并到单个数组里。<br>但是这不是我们打算做的，因为我们已经知道如何创建网格。我们的cube不需要有重复的顶点，这种做法很有趣。<br>我们需要多少顶点呢？让我们按类型分解，首先8个角顶点，这很简单。有12条边，每四条在同向。因为我们不包括角，每个边都有一个等于相应大小的顶点减去一个顶点。或者，把它看作四组x、y和z边。</p>
<p><code>4(#x + #y + #z - 3)</code></p>
<p>其余的顶点是那些位于面部边缘的顶点。这是相当于一个重复的顶点，其体积缩小了2</p>
<p><code>2((#x - 1)(#y - 1) + (#x - 1)(#z - 1) + (#y - 1)(#z - 1))</code></p>
<p>这样计算出的结果就是最终所需顶点数</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> IEnumerator <span class="title">Generate</span> (<span class="params"></span>) </span>&#123;</div><div class="line">		GetComponent&lt;MeshFilter&gt;().mesh = mesh = <span class="keyword">new</span> Mesh();</div><div class="line">		mesh.name = <span class="string">"Procedural Cube"</span>;</div><div class="line">		WaitForSeconds wait = <span class="keyword">new</span> WaitForSeconds(<span class="number">0.05</span>f);</div><div class="line"></div><div class="line">		<span class="keyword">int</span> cornerVertices = <span class="number">8</span>;</div><div class="line">		<span class="keyword">int</span> edgeVertices = (xSize + ySize + zSize - <span class="number">3</span>) * <span class="number">4</span>;</div><div class="line">		<span class="keyword">int</span> faceVertices = (</div><div class="line">			(xSize - <span class="number">1</span>) * (ySize - <span class="number">1</span>) +</div><div class="line">			(xSize - <span class="number">1</span>) * (zSize - <span class="number">1</span>) +</div><div class="line">			(ySize - <span class="number">1</span>) * (zSize - <span class="number">1</span>)) * <span class="number">2</span>;</div><div class="line">		vertices = <span class="keyword">new</span> Vector3[cornerVertices + edgeVertices + faceVertices];</div><div class="line"></div><div class="line">		<span class="keyword">yield</span> <span class="keyword">return</span> wait;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>现在定位一个面上的第一行顶点就像定位网格上的第一行顶点。(参考章节.1)<br>基础的算法是从x(0,0)开始，计算算一圈的点</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> v = <span class="number">0</span>; <span class="comment">//索引</span></div><div class="line"><span class="comment">//算出X轴线的点</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= xSize; x++)</div><div class="line">&#123;</div><div class="line">    Vertices[v++] = <span class="keyword">new</span> Vector3(x, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> wait;</div><div class="line">&#125;</div><div class="line"><span class="comment">//算出y轴线的点</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">1</span>; z &lt;= zSize; z++)</div><div class="line">&#123;</div><div class="line">    Vertices[v++] = <span class="keyword">new</span> Vector3(xSize, <span class="number">0</span>, z);</div><div class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> wait;</div><div class="line">&#125;</div><div class="line"><span class="comment">//x轴线背后的点</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = (<span class="keyword">int</span>)xSize - <span class="number">1</span>; x &gt;= <span class="number">0</span>; x--)</div><div class="line">&#123;</div><div class="line">    Vertices[v++] = <span class="keyword">new</span> Vector3(x, <span class="number">0</span>, zSize);</div><div class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> wait;</div><div class="line">&#125;</div><div class="line"><span class="comment">//z轴线背后的点</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> z = (<span class="keyword">int</span>)zSize - <span class="number">1</span>; z &gt; <span class="number">0</span>; z--)</div><div class="line">&#123;</div><div class="line">    Vertices[v++] = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, z);</div><div class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> wait;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由以上基础我们可以直接绘制出第0层至顶层的点<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> v = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt;= ySize; y++)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//算出X轴线的点</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= xSize; x++)</div><div class="line">    &#123;</div><div class="line">        Vertices[v++] = <span class="keyword">new</span> Vector3(x, y, <span class="number">0</span>);</div><div class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> wait;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//算出y轴线的点</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">1</span>; z &lt;= zSize; z++)</div><div class="line">    &#123;</div><div class="line">        Vertices[v++] = <span class="keyword">new</span> Vector3(xSize, y, z);</div><div class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> wait;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//x轴线背后的点</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = (<span class="keyword">int</span>)xSize - <span class="number">1</span>; x &gt;= <span class="number">0</span>; x--)</div><div class="line">    &#123;</div><div class="line">        Vertices[v++] = <span class="keyword">new</span> Vector3(x, y, zSize);</div><div class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> wait;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//z轴线背后的点</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> z = (<span class="keyword">int</span>)zSize - <span class="number">1</span>; z &gt; <span class="number">0</span>; z--)</div><div class="line">    &#123;</div><div class="line">        Vertices[v++] = <span class="keyword">new</span> Vector3(<span class="number">0</span>, y, z);</div><div class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> wait;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//顶层内部的点</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">1</span>; z &lt; zSize; z++)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; xSize; x++)</div><div class="line">    &#123;</div><div class="line">        Vertices[v++] = <span class="keyword">new</span> Vector3(x, ySize, z);</div><div class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> wait;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//底层内部的点</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">1</span>; z &lt; zSize; z++)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; xSize; x++)</div><div class="line">    &#123;</div><div class="line">        Vertices[v++] = <span class="keyword">new</span> Vector3(x, <span class="number">0</span>, z);</div><div class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> wait;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Add-rounded-edges-to-the-cube-添加圆形边缘的立方体"><a href="#Add-rounded-edges-to-the-cube-添加圆形边缘的立方体" class="headerlink" title="Add rounded edges to the cube. 添加圆形边缘的立方体"></a>Add rounded edges to the cube. 添加圆形边缘的立方体</h1><p>和上一章类似，我们这样绘制四边形<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span></span></div><div class="line"><span class="title">SetQuad</span> (<span class="params"><span class="keyword">int</span>[] triangles, <span class="keyword">int</span> i, <span class="keyword">int</span> v00, <span class="keyword">int</span> v10, <span class="keyword">int</span> v01, <span class="keyword">int</span> v11</span>) &#123;</div><div class="line">    triangles[i] = v00;</div><div class="line">    triangles[i + <span class="number">1</span>] = triangles[i + <span class="number">4</span>] = v01;</div><div class="line">    triangles[i + <span class="number">2</span>] = triangles[i + <span class="number">3</span>] = v10;</div><div class="line">    triangles[i + <span class="number">5</span>] = v11;</div><div class="line">    <span class="keyword">return</span> i + <span class="number">6</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/uploads/03-quad.png" alt="四边形图解"></p>
<p>与顶点不同，三角形的数目等于六个面的总和。他们是否使用共享顶点并不重要。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateTriangles</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">int</span> quads = (<span class="keyword">int</span>)(xSize * ySize + xSize * zSize + ySize * zSize) * <span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span>[] triangles = <span class="keyword">new</span> <span class="keyword">int</span>[quads * <span class="number">6</span>];</div><div class="line">    mesh.triangles = triangles;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建横向的三角方式与创建网格的做法相同。至此为止位置不同的是顶点在下一行的偏移相当全部的环形顶点之和。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateTriangles</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">int</span> quads = (xSize * ySize + xSize * zSize + ySize * zSize) * <span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span>[] triangles = <span class="keyword">new</span> <span class="keyword">int</span>[quads * <span class="number">6</span>];</div><div class="line">    <span class="keyword">int</span> ring = (xSize + zSize) * <span class="number">2</span>; <span class="comment">//计算环偏移</span></div><div class="line">    <span class="keyword">int</span> t = <span class="number">0</span>, v = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; ySize; y++, v++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">0</span>; q &lt; ring - <span class="number">1</span>; q++, v++) &#123;</div><div class="line">            t = SetQuad(triangles, t, v, v + <span class="number">1</span>, v + ring, v + ring + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        t = SetQuad(triangles, t, v, v - ring + <span class="number">1</span>, v + ring, v + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    t = CreateTopFace(triangles, t, ring);</div><div class="line">    t = CreateBottomFace(triangles, t, ring);</div><div class="line">    mesh.triangles = triangles;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很不幸顶部与底部的面并不简单。顶点的布局就像是一个网格被环包围。</p>
<p><img src="/uploads/03-cap.png" alt="盖子就像在环里的网格"></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">CreateTopFace</span> (<span class="params"><span class="keyword">int</span>[] triangles, <span class="keyword">int</span> t, <span class="keyword">int</span> ring</span>) </span>&#123;</div><div class="line">    <span class="keyword">int</span> v = ring * ySize;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; xSize - <span class="number">1</span>; x++, v++) &#123;</div><div class="line">        t = SetQuad(triangles, t, v, v + <span class="number">1</span>, v + ring - <span class="number">1</span>, v + ring);</div><div class="line">    &#125;</div><div class="line">    t = SetQuad(triangles, t, v, v + <span class="number">1</span>, v + ring - <span class="number">1</span>, v + <span class="number">2</span>);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> vMin = ring * (ySize + <span class="number">1</span>) - <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> vMid = vMin + <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> vMax = v + <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">1</span>; z &lt; zSize - <span class="number">1</span>; z++, vMin--, vMid++, vMax++) &#123;</div><div class="line">        t = SetQuad(triangles, t, vMin, vMid, vMin - <span class="number">1</span>, vMid + xSize - <span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; xSize - <span class="number">1</span>; x++, vMid++) &#123;</div><div class="line">            t = SetQuad(</div><div class="line">                triangles, t,</div><div class="line">                vMid, vMid + <span class="number">1</span>, vMid + xSize - <span class="number">1</span>, vMid + xSize);</div><div class="line">        &#125;</div><div class="line">        t = SetQuad(triangles, t, vMid, vMax, vMid + xSize - <span class="number">1</span>, vMax + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> vTop = vMin - <span class="number">2</span>;</div><div class="line">    t = SetQuad(triangles, t, vMin, vMid, vTop + <span class="number">1</span>, vTop);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; xSize - <span class="number">1</span>; x++, vTop--, vMid++) &#123;</div><div class="line">        t = SetQuad(triangles, t, vMid, vMid + <span class="number">1</span>, vTop, vTop - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    t = SetQuad(triangles, t, vMid, vTop - <span class="number">2</span>, vTop, vTop - <span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> t;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">CreateBottomFace</span> (<span class="params"><span class="keyword">int</span>[] triangles, <span class="keyword">int</span> t, <span class="keyword">int</span> ring</span>) </span>&#123;</div><div class="line">    <span class="keyword">int</span> v = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> vMid = vertices.Length - (xSize - <span class="number">1</span>) * (zSize - <span class="number">1</span>);</div><div class="line">    t = SetQuad(triangles, t, ring - <span class="number">1</span>, vMid, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; xSize - <span class="number">1</span>; x++, v++, vMid++) &#123;</div><div class="line">        t = SetQuad(triangles, t, vMid, vMid + <span class="number">1</span>, v, v + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    t = SetQuad(triangles, t, vMid, v + <span class="number">2</span>, v, v + <span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> vMin = ring - <span class="number">2</span>;</div><div class="line">    vMid -= xSize - <span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> vMax = v + <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">1</span>; z &lt; zSize - <span class="number">1</span>; z++, vMin--, vMid++, vMax++) &#123;</div><div class="line">        t = SetQuad(triangles, t, vMin, vMid + xSize - <span class="number">1</span>, vMin + <span class="number">1</span>, vMid);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; xSize - <span class="number">1</span>; x++, vMid++) &#123;</div><div class="line">            t = SetQuad(</div><div class="line">                triangles, t,</div><div class="line">                vMid + xSize - <span class="number">1</span>, vMid + xSize, vMid, vMid + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        t = SetQuad(triangles, t, vMid + xSize - <span class="number">1</span>, vMax + <span class="number">1</span>, vMid, vMax);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> vTop = vMin - <span class="number">1</span>;</div><div class="line">    t = SetQuad(triangles, t, vTop + <span class="number">1</span>, vTop, vTop + <span class="number">2</span>, vMid);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; xSize - <span class="number">1</span>; x++, vTop--, vMid++) &#123;</div><div class="line">        t = SetQuad(triangles, t, vTop, vTop - <span class="number">1</span>, vMid, vMid + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    t = SetQuad(triangles, t, vTop, vTop - <span class="number">1</span>, vMid, vTop - <span class="number">2</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> t;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章讲到Mesh的工作原理以及顶点与三角形的算法.本章主题如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Create a cube with a seamless mesh. 创建无缝Mesh的立方体&lt;/li&gt;
&lt;li&gt;Add rounded edges to the cube. 添加圆形边缘的立方体&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此为本人阅读笔记不作为转载处理,详细还请参看原文. &lt;a href=&quot;http://catlikecoding.com/unity/tutorials/&quot;&gt;原文地址&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="翻译" scheme="http://vrast.cn/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="UNITY3D" scheme="http://vrast.cn/tags/UNITY3D/"/>
    
  </entry>
  
</feed>
